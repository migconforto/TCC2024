# -*- coding: utf-8 -*-
"""TCC_leitura_v02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1c1zZvQjQB3LZHvmFOTZo_6X_UJay4JnC
"""

!pip install rasterio
!pip install hickle

#Acesso ao Drive
import matplotlib.pyplot as plt
from google.colab import drive
drive.mount('/content/drive')

# Contains all the constants defined in the project
import os

# paths to the current folder
current_dir_path = "/content/drive/MyDrive/Dados_TCC_2024/"

img_rows = 100  # patch height
img_cols = 100  # patch width
osm_features = 56  # number of osm based features

# paths to So2Sat POP Part1 folder
all_patches_mixed_part1 = os.path.join(current_dir_path, 'So2Sat_POP_Part1')  # path to So2Sat POP Part 1 data folder
#all_patches_mixed_train_part1 = os.path.join(all_patches_mixed_part1, 'train')   # path to train folder
#all_patches_mixed_test_part1 = os.path.join(all_patches_mixed_part1, 'test')   # path to test folder

# paths to So2Sat POP Part2 folder
all_patches_mixed_part2 = os.path.join(current_dir_path, 'So2Sat_POP_Part2')  # path to So2Sat POP Part 2 data folder
#all_patches_mixed_train_part2 = os.path.join(all_patches_mixed_part2, 'train')   # path to train folder
#all_patches_mixed_test_part2 = os.path.join(all_patches_mixed_part2, 'test')   # path to test folder

# covariates used to train the model
covariate_list = ['DEM_MEAN', 'DEM_MAX', 'LCZ_CL', 'LU_1_A', 'LU_2_A', 'LU_3_A', 'LU_4_A', 'VIIRS_MEAN', 'VIIRS_MAX',
                  'SEN2_AUT_MEAN_R', 'SEN2_AUT_MEAN_G', 'SEN2_AUT_MEAN_B', 'SEN2_AUT_MED_R', 'SEN2_AUT_MED_G',
                  'SEN2_AUT_MED_B', 'SEN2_AUT_STD_R', 'SEN2_AUT_STD_G', 'SEN2_AUT_STD_B', 'SEN2_AUT_MAX_R',
                  'SEN2_AUT_MAX_G', 'SEN2_AUT_MAX_B', 'SEN2_AUT_MIN_R', 'SEN2_AUT_MIN_G', 'SEN2_AUT_MIN_B',
                  'SEN2_SPR_MEAN_R', 'SEN2_SPR_MEAN_G', 'SEN2_SPR_MEAN_B', 'SEN2_SPR_MED_R', 'SEN2_SPR_MED_G',
                  'SEN2_SPR_MED_B', 'SEN2_SPR_STD_R', 'SEN2_SPR_STD_G', 'SEN2_SPR_STD_B', 'SEN2_SPR_MAX_R',
                  'SEN2_SPR_MAX_G', 'SEN2_SPR_MAX_B', 'SEN2_SPR_MIN_R', 'SEN2_SPR_MIN_G', 'SEN2_SPR_MIN_B',
                  'SEN2_SUM_MEAN_R', 'SEN2_SUM_MEAN_G', 'SEN2_SUM_MEAN_B', 'SEN2_SUM_MED_R', 'SEN2_SUM_MED_G',
                  'SEN2_SUM_MED_B', 'SEN2_SUM_STD_R', 'SEN2_SUM_STD_G', 'SEN2_SUM_STD_B', 'SEN2_SUM_MAX_R',
                  'SEN2_SUM_MAX_G', 'SEN2_SUM_MAX_B', 'SEN2_SUM_MIN_R', 'SEN2_SUM_MIN_G', 'SEN2_SUM_MIN_B',
                  'SEN2_WIN_MEAN_R', 'SEN2_WIN_MEAN_G', 'SEN2_WIN_MEAN_B', 'SEN2_WIN_MED_R', 'SEN2_WIN_MED_G',
                  'SEN2_WIN_MED_B', 'SEN2_WIN_STD_R', 'SEN2_WIN_STD_G', 'SEN2_WIN_STD_B', 'SEN2_WIN_MAX_R',
                  'SEN2_WIN_MAX_G', 'SEN2_WIN_MAX_B', 'SEN2_WIN_MIN_R', 'SEN2_WIN_MIN_G', 'SEN2_WIN_MIN_B',
                  'aerialway', 'aeroway', 'amenity', 'barrier', 'boundary', 'building', 'craft', 'emergency', 'geological',
                  'healthcare', 'highway', 'historic', 'landuse', 'leisure', 'man_made', 'military', 'natural',
                  'office', 'place', 'power', 'public_transport', 'railway', 'route', 'shop', 'sport', 'telecom',
                  'tourism', 'water', 'waterway', 'addr:housenumber', 'restrictions', 'other', 'n', 'm', 'k_avg',
                  'intersection_count', 'streets_per_node_avg', 'streets_per_node_counts_argmin',
                  'streets_per_node_counts_min', 'streets_per_node_counts_argmax', 'streets_per_node_counts_max',
                  'streets_per_node_proportions_argmin', 'streets_per_node_proportions_min',
                  'streets_per_node_proportions_argmax', 'streets_per_node_proportions_max', 'edge_length_total',
                  'edge_length_avg', 'street_length_total', 'street_length_avg', 'street_segment_count',
                  'node_density_km', 'intersection_density_km', 'edge_density_km', 'street_density_km', 'circuity_avg',
                  'self_loop_proportion']

band_index = {
    'aero':      1,
    'blue':      2,
    'green':     3,
    'red':       4,
    'red_edge':  5,
    'red_edge2': 6,
    'red_edge3': 7,
    'nir':       8,
    'nirn':      9,
    'water':     10,
    'swir':      11,
    'swir2':     12,
    'swir3':     13
}

band_combination = { #To image-array
    'RGB': [3,2,1],
    'Agriculture': [11,7,1],
    'Color Infrared': [7,3,2],
    'Short Wave': [12,11,2],
    'Geology': [12,11,1],
    'Bathymetric': [3,2,0],
    'Normalized Burn Ratio': [7,11,12],
    'NDVI (Raw, VRE)': [7,5,4,3],
    'NDMI (Corized, Raw, VRE)': [7,4,2]
}

min_fimportance = 0.002

# Parameter for the Grid Search for hyperparameter optimization
#param_grid = {'oob_score': [True], 'bootstrap': [True],
#              'max_features': ['sqrt', 0.05, 0.1, 0.2, 0.3, 0.4],
#              'n_estimators': [250, 350, 500, 750, 1000]}

# Kfold parameter
kfold = 5
n_jobs = -1

"""
Generic data reader.
Returns all the patches with attributes of a given data and
their corresponding population count and population class labels

Note: Reads from both So2Sat POP Part1 and So2Sat POP Part2 data folders.
"""
import rasterio
import glob
import numpy as np
import pandas as pd

from rasterio.enums import Resampling

def load_data(f_names, channels):
    """
    :param f_names: path to all the files of a data folder
    :param channels: number of channels corresponding to the data
    :return: all the instances of a data with its attributes
    """
    X = np.empty((len(f_names), img_rows, img_cols, channels))
    for i, ID in enumerate(f_names):

        # load tif file
        with rasterio.open(ID, 'r') as ds:
          if channels == 13: #lendo as bandas do Sentinel-2
            # Carregando bandas
            image = []
            for index in band_index.values():
              band = ds.read(index,resampling=Resampling.average)
              # Normalizando as bandas
              band_normalized = band/2**12
              image.append(band_normalized)

            # Empilhar as bandas em um único array
            image = np.array(image)
            image = np.transpose(image, (1, 2, 0))
            new_arr = np.empty([img_rows, img_cols, channels])

            for k, layer in enumerate(image):
              arr = layer
              new_arr[k] = arr
              X[i, ] = new_arr

          else: #Seguindo para demais bandas
            image = ds.read(out_shape=(ds.count, img_rows, img_cols), resampling=Resampling.average)
            new_arr = np.empty([channels, img_rows, img_cols])

            for k, layer in enumerate(image):
              arr = layer
              new_arr[k] = arr
              X[i, ] = np.transpose(new_arr, (1, 2, 0))
    return X


def load_osm_data(f_names, channels):
    """
    :param f_names: path to all the files of osm_features data folder
    :param channels: number of channels corresponding to the osm_features data
    :return: all the instances of osm_features data with its attributes
    """
    X = np.empty((len(f_names), osm_features, channels))
    for i, ID in enumerate(f_names):
        # load csv
        df = pd.read_csv(ID, header=None)[1]
        # remove inf and Nan values
        df = df[df.notna()]
        df_array = np.array(df)
        df_array[df_array == np.inf] = 0

        new_arr = np.empty([channels, osm_features])

        new_arr[0] = df_array

        X[i, ] = np.transpose(new_arr, (1, 0))
    return X


def get_fnames_labels(folder_path, data):
    """
    :param folder_path: path to so2sat sub folder test/train
    :param data: name of the data folder, ex: 'lcz', 'lu', ...
    :return: all the instances of a data with its attributes and labels (population count & class) of each instance
    """
    city_folders = glob.glob(os.path.join(folder_path, "*"))  # list all the cities in folder_path
    f_names_all = np.array([])  # file names
    c_labels_all = np.array([])  # class labels
    p_count_all = np.array([])  # population counts
    for each_city in city_folders:
        data_path = os.path.join(each_city, data)  # path to the specifies data folder
        if data == 'dem':  # for dem data also, load the csv from So2Sat POP Part 1
            csv_path = os.path.join(each_city.replace('Part2', 'Part1'), each_city.split(os.sep)[-1:][0] + '.csv')
            #city_df = pd.read_csv(csv_path)  # read csv as dataframe
        else:
            csv_path = os.path.join(each_city, each_city.split(os.sep)[-1:][0] + '.csv')  # path to the cvs file of the city
            #city_df = pd.read_csv(csv_path)  # read csv as dataframe

        city_df = pd.read_csv(csv_path)  # read csv as dataframe
        ids = city_df['GRD_ID']  # get the id of each patch
        pop = city_df['POP']  # corresponding pop count
        classes = city_df['Class']  # corresponding Class
        classes_str = [str(x) for x in classes]
        classes_paths = [data_path + '/Class_' + x + '/' for x in classes_str]
        for index in range(0, len(classes_paths)):
            if data == 'osm_features':  # osm features ends with '.csv'
                f_names = [classes_paths[index] + ids[index] + '_' + data + '.csv']  # creating full path for each id
            else:
                f_names = [classes_paths[index] + ids[index] + '_' + data + '.tif']  # creating full path for each id
            f_names_all = np.append(f_names_all, f_names, axis=0)  # append file names together
            pop_count = [pop[index]]
            p_count_all = np.append(p_count_all, pop_count, axis=0)   # append pop count together
            class_label = [classes[index]]
            c_labels_all = np.append(c_labels_all, class_label, axis=0)  # append class labels together

    if data.__contains__('sen2'):
        X = load_data(f_names_all, channels=13)  # load the data for sentinel-2 files

    if data == 'viirs' or data == 'lcz' or data == "dem":
        X = load_data(f_names_all, channels=1)  # load the data for viirs, lcz, dem files

    if data == 'lu':
        X = load_data(f_names_all, channels=4)  # load the data for lu files

    if data == 'osm_features':  # load the data for osm features files
        X = load_osm_data(f_names_all, channels=1)

    return X, p_count_all, c_labels_all


if __name__ == "__main__":

    # load all the files and their corresponding population count and class for "sen2_rgb_autumn" data in "train" folder
    X_train_sen2_rgb_autumn,  y_train_count, y_train_class = get_fnames_labels(all_patches_mixed_part1,
                                                                               data='sen2autumn')
    # load all the files and their corresponding population count and class for "sen2_rgb_autumn" data in "test" folder
    #X_test_sen2_rgb_autumn,  y_test_count, y_test_class = get_fnames_labels(all_patches_mixed_part1,
    #                                                                        data='sen2autumn')

    # load all the files and their corresponding population count and class for "sen2_rgb_summer" data in "train" folder
    X_train_sen2_rgb_summer,  y_train_count, y_train_class = get_fnames_labels(all_patches_mixed_part1,
                                                                               data='sen2summer')
    # load all the files and their corresponding population count and class for "sen2_rgb_summer" data in "test" folder
    #X_test_sen2_rgb_summer,  y_test_count, y_test_class = get_fnames_labels(all_patches_mixed_part1,
    #                                                                        data='sen2summer')

    # load all the files and their corresponding population count and class for "sen2_rgb_spring" data in "train" folder
    X_train_sen2_rgb_spring,  y_train_count, y_train_class = get_fnames_labels(all_patches_mixed_part1,
                                                                               data='sen2spring')
    # load all the files and their corresponding population count and class for "sen2_rgb_spring" data in "test" folder
    #X_test_sen2_rgb_spring,  y_test_count, y_test_class = get_fnames_labels(all_patches_mixed_part1,
    #                                                                        data='sen2spring')

    # load all the files and their corresponding population count and class for "sen2_rgb_winter" data in "train" folder
    X_train_sen2_rgb_winter,  y_train_count, y_train_class = get_fnames_labels(all_patches_mixed_part1,
                                                                               data='sen2winter')
    # load all the files and their corresponding population count and class for "sen2_rgb_winter" data in "test" folder
    #X_test_sen2_rgb_winter,  y_test_count, y_test_class = get_fnames_labels(all_patches_mixed_part1,
    #                                                                        data='sen2winter')

    # load all the files and their corresponding population count and class for "viirs" data in "train" folder
    X_train_viirs,  y_train_count, y_train_class = get_fnames_labels(all_patches_mixed_part1, data='viirs')
    # load all the files and their corresponding population count and class for "viirs" data in "test" folder
    #X_test_viirs,  y_test_count, y_test_class = get_fnames_labels(all_patches_mixed_part1, data='viirs')

    # load all the files and their corresponding population count and class for "lcz" data in "train" folder
    X_train_lcz,  y_train_count, y_train_class = get_fnames_labels(all_patches_mixed_part1, data='lcz')
    # load all the files and their corresponding population count and class for "lcz" data in "test" folder
    #X_test_lcz,  y_test_count, y_test_class = get_fnames_labels(all_patches_mixed_part1, data='lcz')

    # load all the files and their corresponding population count and class for "lu" data in "train" folder
    X_train_lu,  y_train_count, y_train_class = get_fnames_labels(all_patches_mixed_part1, data='lu')
    # load all the files and their corresponding population count and class for "lu" data in "test" folder
    #X_test_lu,  y_test_count, y_test_class = get_fnames_labels(all_patches_mixed_part1, data='lu')

    # load all the files and their corresponding population count and class for "dem" data in "train" folder
    X_train_dem, y_train_count, y_train_class = get_fnames_labels(all_patches_mixed_part2, data='dem')
    # load all the files and their corresponding population count and class for "dem" data in "test" folder
    #X_test_dem, y_test_count, y_test_class = get_fnames_labels(all_patches_mixed_part2, data='dem')

    # load all the files and their corresponding population count and class for "osm" data in "train" folder
    X_train_osm, y_train_count, y_train_class = get_fnames_labels(all_patches_mixed_part1, data='osm_features')
    # load all the files and their corresponding population count and class for "osm" data in "test" folder
    #X_test_osm, y_test_count, y_test_class = get_fnames_labels(all_patches_mixed_part2, data='osm_features')

    print('All instances are loaded')

!pip install hickle

import hickle as hkl

# Salvando os dados de treino
hkl.dump(X_train_sen2_rgb_autumn, '/content/drive/MyDrive/Dados_TCC_2024/train_vec/X_train_sen2_rgb_autumn.hkl')
hkl.dump(X_train_sen2_rgb_summer, '/content/drive/MyDrive/Dados_TCC_2024/train_vec/X_train_sen2_rgb_summer.hkl')
hkl.dump(X_train_sen2_rgb_spring, '/content/drive/MyDrive/Dados_TCC_2024/train_vec/X_train_sen2_rgb_spring.hkl')
hkl.dump(X_train_sen2_rgb_winter, '/content/drive/MyDrive/Dados_TCC_2024/train_vec/X_train_sen2_rgb_winter.hkl')
hkl.dump(X_train_viirs, '/content/drive/MyDrive/Dados_TCC_2024/train_vec/X_train_viirs.hkl')
hkl.dump(X_train_lcz, '/content/drive/MyDrive/Dados_TCC_2024/train_vec/X_train_lcz.hkl')
hkl.dump(X_train_lu, '/content/drive/MyDrive/Dados_TCC_2024/train_vec/X_train_lu.hkl')
hkl.dump(X_train_dem, '/content/drive/MyDrive/Dados_TCC_2024/train_vec/X_train_dem.hkl')
hkl.dump(X_train_osm, '/content/drive/MyDrive/Dados_TCC_2024/train_vec/X_train_osm.hkl')
hkl.dump(y_train_count, '/content/drive/MyDrive/Dados_TCC_2024/train_vec/y_train_count.hkl')
hkl.dump(y_train_class, '/content/drive/MyDrive/Dados_TCC_2024/train_vec/y_train_class.hkl')

# # Salvando os dados de teste (descomente se você tiver os dados de teste)
# hkl.dump(X_test_sen2_rgb_autumn, 'X_test_sen2_rgb_autumn.hkl')
# hkl.dump(X_test_sen2_rgb_summer, 'X_test_sen2_rgb_summer.hkl')
# hkl.dump(X_test_sen2_rgb_spring, 'X_test_sen2_rgb_spring.hkl')
# hkl.dump(X_test_sen2_rgb_winter, 'X_test_sen2_rgb_winter.hkl')
# hkl.dump(X_test_viirs, 'X_test_viirs.hkl')
# hkl.dump(X_test_lcz, 'X_test_lcz.hkl')
# hkl.dump(X_test_lu, 'X_test_lu.hkl')
# hkl.dump(X_test_dem, 'X_test_dem.hkl')
# hkl.dump(X_test_osm, 'X_test_osm.hkl')
# hkl.dump(y_test_count, 'y_test_count.hkl')
# hkl.dump(y_test_class, 'y_test_class.hkl')

print('Dados salvos em arquivos .hkl')

import matplotlib.pyplot as plt
for image in range(len(X_train_sen2_rgb_autumn)):
  # Criar figura e eixos 3x3
  fig, axs = plt.subplots(3, 3, figsize=(15, 15))
  for i, (key, value) in enumerate(band_combination.items()):
      row = i // 3
      col = i % 3

      # Mostrar a imagem no eixo correspondente
      axs[row, col].imshow(X_train_sen2_rgb_summer[image][:, :, value])

      # Definir título do plot
      axs[row, col].set_title(key)

      # Desativar eixos
      axs[row, col].axis('off')

  # Ajustar layout
  plt.tight_layout()

  # Mostrar figura
  plt.show()

import hickle as hkl

# Carregando os dados de treino
#X_train_viirs = hkl.load('/content/drive/MyDrive/Dados_TCC_2024/train_vec/X_train_viirs.hkl')
#X_train_sen2_rgb_summer = hkl.load('/content/drive/MyDrive/Dados_TCC_2024/train_vec/X_train_sen2_rgb_summer.hkl')
#X_train_lu = hkl.load('/content/drive/MyDrive/Dados_TCC_2024/train_vec/X_train_lu.hkl')
#X_train_lcz = hkl.load('/content/drive/MyDrive/Dados_TCC_2024/train_vec/X_train_lcz.hkl')
#X_train_dem = hkl.load('/content/drive/MyDrive/Dados_TCC_2024/train_vec/X_train_dem.hkl')
#X_train_osm = hkl.load('/content/drive/MyDrive/Dados_TCC_2024/train_vec/X_train_osm.hkl')

for i in range(X_train_lu.shape[0]):
  fig, ax = plt.subplots(1, 5, figsize=(5, 5))
  # Plote a primeira imagem (sen2) no subplot da esquerda
  print(f"fig {i}")
  ax[0].imshow(X_train_sen2_rgb_summer[i][:,:,[3,2,1]])
  ax[0].set_title('Sentinel-2 Image')
  ax[0].axis('off')

  # Plote a segunda imagem (viirs) no subplot da direita
  ax[1].imshow(X_train_lu[i][:,:,0], cmap='viridis')
  ax[1].set_title('LU 0')
  ax[1].axis('off')

  ax[2].imshow(X_train_lu[i][:,:,1], cmap='viridis')
  ax[2].set_title('LU 1')
  ax[2].axis('off')

  ax[3].imshow(X_train_lu[i][:,:,2], cmap='viridis')
  ax[3].set_title('LU 2')
  ax[3].axis('off')

  ax[4].imshow(X_train_lu[i][:,:,3], cmap='viridis')
  ax[4].set_title('LU 3')
  ax[4].axis('off')

  # Ajuste o layout e exiba a figura
  plt.tight_layout()
  plt.show()

"""fig 211  
fig 218  
fig 359  
fig 366  
fig 1010  
fig 1057  
fig 1143
"""

fig, ax = plt.subplots(1, 5, figsize=(15, 15))
# Plote a primeira imagem (sen2) no subplot da esquerda
print(f"fig {1057}")
ax[0].imshow(X_train_sen2_rgb_summer[1057][:,:,[3,2,1]])
ax[0].set_title('Sentinel')
ax[0].axis('off')
# Plote a segunda imagem (viirs) no subplot da direita
ax[1].imshow(X_train_lu[1057][:,:,0], cmap='viridis')
ax[1].set_title('LU 0')
ax[1].axis('off')
ax[2].imshow(X_train_lu[1057][:,:,1], cmap='viridis')
ax[2].set_title('LU 1')
ax[2].axis('off')
ax[3].imshow(X_train_lu[1057][:,:,2], cmap='viridis')
ax[3].set_title('LU 2')
ax[3].axis('off')
ax[4].imshow(X_train_lu[1057][:,:,3], cmap='viridis')
ax[4].set_title('LU 3')
ax[4].axis('off')
# Ajuste o layout e exiba a figura
plt.tight_layout()
plt.show()

X_train_lcz

fig, ax = plt.subplots(1, 2, figsize=(15, 15))
# Plote a primeira imagem (sen2) no subplot da esquerda
print(f"fig {1057}")
ax[0].imshow(X_train_sen2_rgb_summer[34][:,:,[3,2,1]])
ax[0].set_title('Sentinel')
ax[0].axis('off')
# Plote a segunda imagem (viirs) no subplot da direita
ax[1].imshow(X_train_dem[34], cmap='gist_gray') #coolwarm_r hot_r Oranges_r
ax[1].set_title('DEM')
ax[1].axis('off')
plt.tight_layout()
plt.show()