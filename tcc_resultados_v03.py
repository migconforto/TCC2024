# -*- coding: utf-8 -*-
"""TCC_resultados_v03.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1a9tXEYi7-Cm4C8z1SOJWa-gaUwOimbPD
"""

#Acesso ao Drive
from google.colab import drive
drive.mount('/content/drive')

# Contains all the constants defined in the project
import os

# paths to the current folder
current_dir_path = "C:/Users/Rumble/Documents/TCC/Script_Python/dados/Dados_TCC_2024/"

img_rows = 100  # patch height
img_cols = 100  # patch width
osm_features = 56  # number of osm based features

# paths to So2Sat POP Part1 folder
all_patches_mixed_part1 = os.path.join(current_dir_path, 'So2Sat_POP_Part1')  # path to So2Sat POP Part 1 data folder
#all_patches_mixed_train_part1 = os.path.join(all_patches_mixed_part1, 'train')   # path to train folder
#all_patches_mixed_test_part1 = os.path.join(all_patches_mixed_part1, 'test')   # path to test folder

# paths to So2Sat POP Part2 folder
all_patches_mixed_part2 = os.path.join(current_dir_path, 'So2Sat_POP_Part2')  # path to So2Sat POP Part 2 data folder
#all_patches_mixed_train_part2 = os.path.join(all_patches_mixed_part2, 'train')   # path to train folder
#all_patches_mixed_test_part2 = os.path.join(all_patches_mixed_part2, 'test')   # path to test folder

# covariates used to train the model
covariate_list = ['DEM_MEAN', 'DEM_MAX', 'LCZ_CL', 'LU_1_A', 'LU_2_A', 'LU_3_A', 'LU_4_A', 'VIIRS_MEAN', 'VIIRS_MAX',
                  'SEN2_AUT_MEAN_R', 'SEN2_AUT_MEAN_G', 'SEN2_AUT_MEAN_B', 'SEN2_AUT_MED_R', 'SEN2_AUT_MED_G',
                  'SEN2_AUT_MED_B', 'SEN2_AUT_STD_R', 'SEN2_AUT_STD_G', 'SEN2_AUT_STD_B', 'SEN2_AUT_MAX_R',
                  'SEN2_AUT_MAX_G', 'SEN2_AUT_MAX_B', 'SEN2_AUT_MIN_R', 'SEN2_AUT_MIN_G', 'SEN2_AUT_MIN_B',
                  'SEN2_SPR_MEAN_R', 'SEN2_SPR_MEAN_G', 'SEN2_SPR_MEAN_B', 'SEN2_SPR_MED_R', 'SEN2_SPR_MED_G',
                  'SEN2_SPR_MED_B', 'SEN2_SPR_STD_R', 'SEN2_SPR_STD_G', 'SEN2_SPR_STD_B', 'SEN2_SPR_MAX_R',
                  'SEN2_SPR_MAX_G', 'SEN2_SPR_MAX_B', 'SEN2_SPR_MIN_R', 'SEN2_SPR_MIN_G', 'SEN2_SPR_MIN_B',
                  'SEN2_SUM_MEAN_R', 'SEN2_SUM_MEAN_G', 'SEN2_SUM_MEAN_B', 'SEN2_SUM_MED_R', 'SEN2_SUM_MED_G',
                  'SEN2_SUM_MED_B', 'SEN2_SUM_STD_R', 'SEN2_SUM_STD_G', 'SEN2_SUM_STD_B', 'SEN2_SUM_MAX_R',
                  'SEN2_SUM_MAX_G', 'SEN2_SUM_MAX_B', 'SEN2_SUM_MIN_R', 'SEN2_SUM_MIN_G', 'SEN2_SUM_MIN_B',
                  'SEN2_WIN_MEAN_R', 'SEN2_WIN_MEAN_G', 'SEN2_WIN_MEAN_B', 'SEN2_WIN_MED_R', 'SEN2_WIN_MED_G',
                  'SEN2_WIN_MED_B', 'SEN2_WIN_STD_R', 'SEN2_WIN_STD_G', 'SEN2_WIN_STD_B', 'SEN2_WIN_MAX_R',
                  'SEN2_WIN_MAX_G', 'SEN2_WIN_MAX_B', 'SEN2_WIN_MIN_R', 'SEN2_WIN_MIN_G', 'SEN2_WIN_MIN_B',
                  'aerialway', 'aeroway', 'amenity', 'barrier', 'boundary', 'building', 'craft', 'emergency', 'geological',
                  'healthcare', 'highway', 'historic', 'landuse', 'leisure', 'man_made', 'military', 'natural',
                  'office', 'place', 'power', 'public_transport', 'railway', 'route', 'shop', 'sport', 'telecom',
                  'tourism', 'water', 'waterway', 'addr:housenumber', 'restrictions', 'other', 'n', 'm', 'k_avg',
                  'intersection_count', 'streets_per_node_avg', 'streets_per_node_counts_argmin',
                  'streets_per_node_counts_min', 'streets_per_node_counts_argmax', 'streets_per_node_counts_max',
                  'streets_per_node_proportions_argmin', 'streets_per_node_proportions_min',
                  'streets_per_node_proportions_argmax', 'streets_per_node_proportions_max', 'edge_length_total',
                  'edge_length_avg', 'street_length_total', 'street_length_avg', 'street_segment_count',
                  'node_density_km', 'intersection_density_km', 'edge_density_km', 'street_density_km', 'circuity_avg',
                  'self_loop_proportion']

satelital_list = ['VIIRS_MEAN', 'VIIRS_MAX','SEN2_AUT_MEAN_R', 'SEN2_AUT_MEAN_G', 'SEN2_AUT_MEAN_B', 'SEN2_AUT_MED_R', 'SEN2_AUT_MED_G',
                  'SEN2_AUT_MED_B', 'SEN2_AUT_STD_R', 'SEN2_AUT_STD_G', 'SEN2_AUT_STD_B', 'SEN2_AUT_MAX_R',
                  'SEN2_AUT_MAX_G', 'SEN2_AUT_MAX_B', 'SEN2_AUT_MIN_R', 'SEN2_AUT_MIN_G', 'SEN2_AUT_MIN_B',
                  'SEN2_SPR_MEAN_R', 'SEN2_SPR_MEAN_G', 'SEN2_SPR_MEAN_B', 'SEN2_SPR_MED_R', 'SEN2_SPR_MED_G',
                  'SEN2_SPR_MED_B', 'SEN2_SPR_STD_R', 'SEN2_SPR_STD_G', 'SEN2_SPR_STD_B', 'SEN2_SPR_MAX_R',
                  'SEN2_SPR_MAX_G', 'SEN2_SPR_MAX_B', 'SEN2_SPR_MIN_R', 'SEN2_SPR_MIN_G', 'SEN2_SPR_MIN_B',
                  'SEN2_SUM_MEAN_R', 'SEN2_SUM_MEAN_G', 'SEN2_SUM_MEAN_B', 'SEN2_SUM_MED_R', 'SEN2_SUM_MED_G',
                  'SEN2_SUM_MED_B', 'SEN2_SUM_STD_R', 'SEN2_SUM_STD_G', 'SEN2_SUM_STD_B', 'SEN2_SUM_MAX_R',
                  'SEN2_SUM_MAX_G', 'SEN2_SUM_MAX_B', 'SEN2_SUM_MIN_R', 'SEN2_SUM_MIN_G', 'SEN2_SUM_MIN_B',
                  'SEN2_WIN_MEAN_R', 'SEN2_WIN_MEAN_G', 'SEN2_WIN_MEAN_B', 'SEN2_WIN_MED_R', 'SEN2_WIN_MED_G',
                  'SEN2_WIN_MED_B', 'SEN2_WIN_STD_R', 'SEN2_WIN_STD_G', 'SEN2_WIN_STD_B', 'SEN2_WIN_MAX_R',
                  'SEN2_WIN_MAX_G', 'SEN2_WIN_MAX_B', 'SEN2_WIN_MIN_R', 'SEN2_WIN_MIN_G', 'SEN2_WIN_MIN_B',
                  'SEN2_AUT_MEAN_NIR','SEN2_AUT_MEAN_SWIR','SEN2_AUT_MED_NIR','SEN2_AUT_MED_SWIR','SEN2_AUT_STD_NIR',
                  'SEN2_AUT_STD_SWIR','SEN2_AUT_MAX_NIR','SEN2_AUT_MAX_SWIR','SEN2_AUT_MIN_NIR','SEN2_AUT_MIN_SWIR',
                  'SEN2_SPR_MEAN_NIR','SEN2_SPR_MEAN_SWIR','SEN2_SPR_MED_NIR','SEN2_SPR_MED_SWIR','SEN2_SPR_STD_NIR',
                  'SEN2_SPR_STD_SWIR','SEN2_SPR_MAX_NIR','SEN2_SPR_MAX_SWIR','SEN2_SPR_MIN_NIR','SEN2_SPR_MIN_SWIR',
                  'SEN2_SUM_MEAN_NIR','SEN2_SUM_MEAN_SWIR','SEN2_SUM_MED_NIR','SEN2_SUM_MED_SWIR','SEN2_SUM_STD_NIR',
                  'SEN2_SUM_STD_SWIR','SEN2_SUM_MAX_NIR','SEN2_SUM_MAX_SWIR','SEN2_SUM_MIN_NIR','SEN2_SUM_MIN_SWIR',
                  'SEN2_WIN_MEAN_NIR','SEN2_WIN_MEAN_SWIR','SEN2_WIN_MED_NIR','SEN2_WIN_MED_SWIR','SEN2_WIN_STD_NIR',
                  'SEN2_WIN_STD_SWIR','SEN2_WIN_MAX_NIR','SEN2_WIN_MAX_SWIR','SEN2_WIN_MIN_NIR','SEN2_WIN_MIN_SWIR']

band_index = {
    'aero':      1,
    'blue':      2,
    'green':     3,
    'red':       4,
    'red_edge':  5,
    'red_edge2': 6,
    'red_edge3': 7,
    'nir':       8,
    'nirn':      9,
    'water':     10,
    'swir':      11,
    'swir2':     12,
    'swir3':     13
}

band_combination = { #To image-array
    'RGB': [3,2,1],
    'Agriculture': [11,7,1],
    'Color Infrared': [7,3,2],
    'Short Wave': [12,11,2],
    'Geology': [12,11,1],
    'Bathymetric': [3,2,0],
    'Normalized Burn Ratio': [7,11,12],
    'NDVI (Raw, VRE)': [7,5,4,3],
    'NDMI (Corized, Raw, VRE)': [7,4,2]
}

min_fimportance = 0.002

!pip install rasterio
!pip install gdal
!pip install kaleido
!pip install imblearn
!pip install xgboost
!pip install plotly

import numpy as np
import rasterio
from rasterio.enums import Resampling
import glob
import os
import time
import _pickle
import kaleido

from sklearn.metrics import roc_curve, auc, roc_auc_score

from plotly import figure_factory as ff
import matplotlib.pyplot as plt

from sklearn.preprocessing import LabelEncoder

from sklearn.model_selection import StratifiedKFold

import pandas as pd
from imblearn.pipeline import Pipeline
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import classification_report, accuracy_score, confusion_matrix, f1_score, precision_score, recall_score, cohen_kappa_score, balanced_accuracy_score

from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor
from xgboost import XGBClassifier, XGBRegressor
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.feature_selection import SelectFromModel

def train_test_sat2pop(ground_truth_col, feature_list):
    """
    :param file_name: substring used for naming of the files
    :param ground_truth_col: column name to be used as ground truth
    :return:
    """
    print("Starting split")
    # get all training cities
    all_cities = glob.glob(os.path.join(all_patches_mixed_part1, '*'))
    # prepare the training dataframe
    features_df = pd.DataFrame()
    for each_city in all_cities:
        #print(f"Processing {each_city}")
        #print(f"Features: {glob.glob(os.path.join(each_city, '*_features.csv'))}")
        if  each_city.endswith('malaga'):
          test_city_csv = glob.glob(os.path.join(each_city, '*_features.csv'))[0]  # get the feature csv
          test_city_df = pd.read_csv(test_city_csv)
        else:
          city_csv = glob.glob(os.path.join(each_city, '*_features.csv'))[0]  # get the feature csv
          city_df = pd.read_csv(city_csv)
          features_df = pd.concat([features_df,city_df], ignore_index=True)  # append data from all the training cities

    # Get the dependent variables
    if ground_truth_col == 'CLASS':
      quantis_desejados = [0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
      valores_de_corte = features_df['POP'].quantile(quantis_desejados)
      features_df['bins'] = pd.cut(features_df['POP'], bins=valores_de_corte, labels=False, include_lowest=True)
      test_city_df['bins'] = pd.cut(test_city_df['POP'], bins=valores_de_corte, labels=False, include_lowest=True)
      y_train = features_df['bins']
      y_test = test_city_df['bins']
      y = np.concatenate((y_train, y_test))
      print(y_train.value_counts())
      print(y_test.value_counts())
      print(features_df['POP'].max())
      print(features_df['POP'].min())
      print(test_city_df['POP'].max())
      print(test_city_df['POP'].min())
      print(valores_de_corte)
    else:
      y_test = test_city_df[ground_truth_col]
      y_train = features_df[ground_truth_col]
      y = np.concatenate((y_train, y_test))

    # Get the independent variables
    x_train = features_df[feature_list] #covariate_list  satelital_list
    x_test = test_city_df[feature_list]
    x = np.concatenate((x_train, x_test))

    # Split the data into training and testing sets
    #x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)
    print("Split complete")
    return x,y,x_train, x_test, y_train, y_test

"""# Class"""

X,y, x_train, x_test, y_train, y_test = train_test_sat2pop(ground_truth_col='CLASS', feature_list=covariate_list)
X_sat,y_sat, x_train_sat, x_test_sat, y_train_sat, y_test_sat = train_test_sat2pop(ground_truth_col='CLASS', feature_list=satelital_list)

from sklearn.decomposition import PCA
# Apply PCA
pca = PCA(n_components=5)
x_train_pca = pca.fit_transform(x_train)
x_test_pca = pca.transform(x_test)

print(f"Number of components kept: {pca.n_components_}")
print(pca.explained_variance_)

explained_variance_ratio = pca.explained_variance_ratio_
print("Explained variance ratio by each principal component:")
for i, variance in enumerate(explained_variance_ratio):
  print(f"PC{i+1}: {variance:.4f}")

cumulative_variance = np.cumsum(explained_variance_ratio)
print("\nCumulative explained variance:")
for i, variance in enumerate(cumulative_variance):
  print(f"PC{i+1}: {variance:.4f}")

# Plotting the explained variance
plt.plot(np.cumsum(pca.explained_variance_ratio_))
plt.xlabel('Number of Components')
plt.ylabel('Cumulative Explained Variance')
plt.title('Explained Variance Ratio by PCA')
plt.show()

[int(x) for x in np.linspace(start=2, stop=20,num=7)]

#Definindo modelos e Grid para cada modelo
models=[]

name = 'RandomForest'
model = RandomForestClassifier(random_state=42,criterion='entropy')
grid = {
    'model__max_depth':[int(x) for x in np.linspace(start=2, stop=20,num=7)],
    'model__n_estimators': [int(x) for x in np.linspace(start=50,stop=1000,num=7)],
#    'model__criterion': ('gini', 'entropy'),
    'model__class_weight': [{0:1, 1:4, 2:4, 3:4, 4:4}, {0:1, 1:1, 2:1, 3:1, 4:1}]
}

models.append({'name': name, 'model': model, 'grid': grid})

#weights = np.where(y == 0, 1, 4)
name = 'XGBoost'
model = XGBClassifier(objective='multi:softmax', device = 'cuda',num_class=5) #objective='multi:softmax' , multi_strategy="multi_output_tree", eval_metric = ''
grid = {
    'model__max_depth': [int(x) for x in np.linspace(start=2, stop=25,num=7)],
    'model__n_estimators': [int(x) for x in np.linspace(start=50,stop=1500,num=5)],
    'model__learning_rate': [float(x) for x in np.linspace(start=0.1, stop=0.3,num=2)],
#    'model__sample_weight': [weights],
#    'model__scale_pos_weight': [0.5, 1, 2]
}

models.append({'name': name, 'model': model, 'grid': grid})

#Função para treinar e testar os modelos
def train_test(mat, X, y):
    model = mat['model']
    name = mat['name']
    grid = mat['grid']

    print(f'Começando {name}.')
    ini = time.time()
    pipe = Pipeline([('model', model)])

    skf = StratifiedKFold(n_splits=5)

    gscv = GridSearchCV(
        pipe,
        param_grid = grid,
        scoring    = 'f1_macro',
        refit      = 'f1_macro',
        cv         = skf,
        verbose    = True,
        n_jobs     = -1,
    )

    rscv = gscv.fit(X,y)
    fim = time.time()
    total_time = fim - ini

    print(f'Término {name} | Score: {round(rscv.best_score_,3)} | Time: {total_time}')
    return {'name':name, 'object': rscv}

#Realizando o GridSearchCV para cada conjunto de treino do K-fold
#Salvar o modelo, o número da iteração, e os vetores resultantes
models_result = []
times_result  = []
info_model    = []
info_values   = []
info_time     = []

grid_result = [train_test(mat, X, y) for mat in models]
models_result = grid_result

for index, mod  in enumerate(grid_result):
  info_model.append(grid_result[index]['name'])
  info_values.append(round(grid_result[index]['object'].best_score_,3))
  info_time.append(grid_result[index]['object'].refit_time_)

times_result.append({'Model': info_model, 'Score': info_values, 'Time': info_time})
dados = pd.DataFrame({'Model': info_model, 'Score': info_values, 'Time': info_time})
fig = ff.create_table(dados, height_constant=20)
fig.show()

"""![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABBwAAADmCAYAAAB23ZZpAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAFHVSURBVHhe7d0NcB3nXej/X2D6ptFcbEe3junlOCGmjXmRMkAq2VPRW+aO5CkppKTISXE6KTIapnNtX7gdLn1DFW0ThgmXv22mw+habfjHNLFppukLjKW5Q2nVa1sEmFiUOoB9Ex9oHbeqbUCoLYXmPr/neXb32T179uyRVq/+fjInPueszp7dZ589+zy/52Vv6uvre1EAAAAAAAAq9F3+XwAAAAAAgMoQcAAAAAAAAJUj4AAAAAAAACpHwAEAAAAAAFSOgAMAAAAAAKgcAQcAAAAAAFA5Ag4AAAAAAKByN/X19b3onze1ZcsW+Z7v+R7/qpxvfvObcvnyZf8KAAAAAADcSFoGHH7gB35A3va2t8l3fVf7nSGmp6fl1KlT/hUAAAAAALhRtAw47Nu3T1796ldLvV7375Rz8803y3d/93fLQw895N8BAAAAAAA3ipYBh7e85S12SMX4+Lh/p5x77rlH7rzzTnn/+9/v30FZQ6MT0n9tXA4cmfHvrA/rdbsBAAAAANVrGXDQXgovfelL5Rvf+IZ/x9H3/vVf/9W/WkF7R2VioOZfLMjssQNy+Ix/uUFUV3HvlUOHR6S7079U9UkZHjvpX1Sr0oDDrkNydH+3dPiX1vysjB86LKsfznDpuun0sIyd8G8BAAAAAFJaTszw7//+7w3BBp3PYWRkRH7sx37Mv7Myeg8elYmBLpk9NizDw/o4LjJwyFT/UKQ+FaXXpNRrg3L04HpJsbpM2u32jzURbAAAAAAAlFHqLhVZOsTi0KFDtvfDo48+KhcuXPBLltOQjE4MipjKc9NW5WyreNyary3S+0Quzkl3T82+PymDMqhP4/VlegPk9ATQgMdIT9LmnnzWSPW8SC/Tz+2T4zK9ecR+p0p9NqcnwsK5pKdA4fcWyrbEu9c7Loa9EFy6xlse7PdSt3tJx8N+dpNMD49Jbn+Mpus24s+el53RvmV6R6TTVAMb4fdk9ytZrr04orQIpfYbAAAAANC6h0Oeq1evyuOPPy7f+c535P7775fNmzfb9zs7O20g4kMf+lD8+MAHPhA//43f+A25/fbb7d+2be9OU3Gsy/mmFW1TcTYV0DlTYc1vze+Q7tuvy/ixWVkw72vX//FzC1K7Y8guHRo1FcyrptJqPzsus1vSPQFcBXUu1eKeVLzNd99xPn5/eKoutYFR826io2fEfqcut9+7O+mZkf7uYZkM5+fcO5r+Xrvuo3Jol1/ejl19ssNUoueuJBXjodGdcj5at0+z0b1+obHo7V7i8SjWat2qJoMT/XLd9oYxyzu7ZU+0X5k0HT/XJYOHk/3qPbgvtV/DQTDi5Ji+Nvlj3gVHor8h2AAAAAAAaYUBh5//+Z9PBQ/CxwMPPGB7OLz85S+3d7LQ5/Pz83ZyyStXrvg1uOEXSodm/P7v/75cvHjRvq5a78F+qc3Pyqk4CHBSxkzlvOP2vrgiWT8dtXDXZTpVQRySnbW6TMY9Gmbk8Onws0Oyp6fDVDCbtLbrd4W9IU6cN9/QJdvCoEB9Mq6Uzjx9QRY6N8l2fbHrkPSnvjvUK4d212Th3Knke0+MmYp9h+y4K6xcF6sNTMjEhHns3yEXTAU87B1xcizcp5Nyvi7StTVY96K2e6nHI6JBA7/t+hh1wYgy61b1qWh+j/R+Dd1RSx3LmSPTUu/cIX3h8artTAWMAAAAAADtWVQPh6xvf/vbctNNN9nnOt/DRz/6Ubl+/bp9/eKLLy57sCF29fLixvjv2iZd2cptMDzCLV+Q6wV3BtWu9vFnwyEKFQh7JCyGa4nXVvmcQIUOBQn2O2+4wKIt9njEdChD0osgNcSl5brTvWG0Z4ILnPTKti1BECbneM0cOSCT9SQ/rJ85LwAAAABg7SgMOPzBH/yBvOc978l9/O7v/q4NNMzNzdlgwr/927/5T4n88z//s3zkIx+Rf/mXf7G9Hh577LGlBxvq102VvyY7g+7+DbZsS7Vw927t8s/KyFRu9RGN+T9zWebs3+TT4RaD2toff3bSrK06qR4HvsLcPt9ro2dP0nKvcx0MaGt/ss/pYRFLtKTj0cIS1x3us3uk73bihk7oY1LmekYIOgAAAABAmxbVw0HnbHj7299ub4upk0Zm72Khvv71r9vWYZ3r4e/+7u/8u0tw5rBMm8pwem6EXjk06sbeu+7+wTj9aBhE3G2/wJmzcmG+JoO+y34j7ZLfId33FdwRY/66XPJPh0bb6OFggxlJIMUFL9xzDRKcvbiQDhLs3SPdnc2GILRw4pTMmv3sT1Weg54be0fL93Ao3O4lHo8WlrZul6bZOTaauyTX5/3T2IxcvmryYtP5JnTSSe0dsci5NgAAAABgA1hUwOGf/umf5IUXXrA9G65du+bfbaRzOVy6FFXDl05bncOu7hMT+0Smol4Ih+XAsVnpirvKD0rXufHUfAXNzcjhQ26iSPdZ9whbtU+OmeXSLSPB8mhyRTcHQLKs/9psGz0c3PwDURf/kc3TdvLEiHbvt5Ma+nW724I2m0uilaiXwz5XEbZBnA7p3u/Xvfu6zJbe8OLtXtrxaGGJ625IU33Ek0ZGwYLo4SbGzE4KeXLMTVQZ/R09IAAAAAAgbVG3xbxxudslJreZBAAAAAAAeVr2cHj9618vb3vb2/yr8nbv3i379++PJ5PcGLbLps6iW3MCAAAAAADVsofDz/7sz8qdd94pn/vc5/w75bzmNa+Rbdu2ya//+q/bO1UAAAAAAIAbR8uAQ09PjwwNlZteL0vvTKF3qwAAAAAAADeWUnM43HbbbfL93//98rWvfc3e8rIM7dXwD//wD6nbZQIAAAAAgBsDk0YCAAAAAIDKLeq2mAAAAAAAAEU2Xg+HXYfk6P5u6ahPyvDYSf9mRZZz3ctt76hMDNT8iwWZPXZADp/xL5uJ9te+qMvk8JgU7fXQ6IT0XxuXA0dm/DtVGJLRiUGJt/xc1etfSSt1W9WNlGYVs3l6k0yn8rJPr/lZGT90WJqnFLfFXbowb+b8DpX5zVnPv8NL4vJfd6d/mdl//f0drJX8bQcAAFgh66qHQ+/BozIxMZF6HD3Y65eWoAXViVFT5M2nBba21rcitICe3ueJw4dM0bMdZh0DNalPDcvwsD5KFkjPHJYD+vfHZk3VYHUMjZrKiRas7XYPU3EuYSlpFp1jo3v9GzGt7AR5cDR7FmXzafPz7Iaigb62z9eV4I5n43EuZ/G/lSdlzObLSan7d1LWwG9OIXsNifL4UTm0y78fi86T7LJW509rvQf3SbfMyrg/r8sHW5Z2rAEAAJZi/Q2pCCpSuZWpqMC6HC1fy7nuQtrSl+zzcGErbI5d26TLrOP8umuV7ZVtW8zeP3sjtWIu1WLTzFVK9smF3IqgVnZ2XBz3edBUFmuDQYVTPzsoEge0hmWyXpPBRVSqVoevBLd7XmF1rNbvsAaP9u+QC8eifN4YuLVBgav1hnNoaHTEvB9du7LnTznbN3fIwsWzTfPoybH8bQIAAFhN62pIhba+jmyeblrQdF1K3fN0N/KwG2/IdT89e5dZb4/rxJsSdFltvm5DC6J3nJfxa/3xerJ/E34+Uq6ru277TjnfYjhDITucQoq7J/uX2W66lv2bbDd0pRXNoIuvUZjuLbusZ7nPa0W2oQt70XbH23tedkbf39Z3Z/arIU0y+9Vqefzdbr2bTk+KDETLWw9VCdlzIMir2mslnTYFaVZA17vnygHzmXKft/lZov3Wz/TL9aArd6tztVGzNFOZ45Fapp8z58ex69If5YfssU4NJ1JJmqfSMy/vZ7fLSKV5Zt3xsmz+jIXHu0U+y6y73O9Fa3m/RSpcf7N8ln0/ltr2TJo1Tdd0nklp8puzer/Deqz2iTxRUKG326wBiWnZtD/Yt/j9zPlx+4W2f5M06Newram8lv49KXOslyufAQAAqA01aaRr4dHWVf9GzLdg2m66YW8BVwCcOXIg/pwWttwy8wgKyc3X7dUGXQVLPzdVl46ePaZI7ZkC3WAt+t5xmZ0375lC+HIX6rRQa7vv2sJkTQYbuvOaQr8pqM6ZyoTb5/Za3tKtdo1po137u8L0LFu41gK03VZXaakN+O2Ou+mX2W7dXy30++Wd3bKnZJfi9H6Z47Ulve6hUQ0Apb876a7sKltF+10biLZL80JN+su2dJp8NNIzl+Rfk89qA77rdss0K6bnQDsBirSTcr7eId37/XeZbdlnKnzle1kUp1nvwT2mouff1zSTbtmXPda2cqrLM8da02WgS2ajVulMV/3o3B8/l9eBXyt54Xb5czdmtttUcN0y87DHw6dB1Apv3rMBkOhvUpXBonxm1h1ut3lU9XvhfsvcviTDrIL1F+SzMr+VxefH0qza7/CuPtnROSdyVzCsLzVUxuSV+7pFzh1vDEjUNknH/AU5G71v07dDpHOTbPdvNafnhn6fC0x19Iz47w+GbBQMQ2l5rJcxnwEAAKj1F3AwBcq4wGcea2ZcqlYqokL3ifNSly7Z5guEQ3eYKmD9vK9ozMjZi6ZYuGVbUFhtJQgW5I4bzhdVDmylJwy0+O3sPdhvJ8o7FVc0T8qYFtJv72u9baYi16+F94aWy7RS68qKCtBaWTEvk4Jy1CpdbrvrU1GLolaIRbq2ltmSIdmZ2q8ZOXw6ve6TY2Gra3rd0bYdLyi0J9vl8kLH5tbVDluh2V0zlbxTyXefGDMVrw7ZcZf57hZpVilbcVuQ2akgFbRiMyUun/pu52UDGK3SbObIWFCJy0sz7akU7Wf6eAwNNKkElrF3jx0z3/xYmnwX5v/MeV+sdT4zZ487tiuqRT4roej8WHbL9TusQQPzO7xDjvvzylTiTe4YiYK3LfOKEQUFbW8zPU/L5BUfLPdBgyTIk/SWWLrVyGcAAOBGse7ncFh8q+zKuXTNFGxrO31LW6/03V48FjctKnD6x9ScdO8vH3Ro6erlktvRvpNjvlDugyWVBodabnd6zgqtEJdrydT5LsIAj1YQtM9AwFS442XmEXZZ1nHWy5mmc1eWa80l2R4DOgFpusKjXbcndl93Lfk2j5afVLBlmkUVNf/I7dK/Sux+x9uWHnpRqGU+M+f9sVmRuEV7ZSfhXFI+Kzg/VtPSfoeNVFDMBYhcwML3EniioAdXp/kdjHvhjMlJe/zn5HJlQYPFWt18BgAANr4NNaRirZq5Mmf+H1UuRlq3hBWxrXYVyrTw9W7t8s+qYArlh3ygxBRquwYqDDos63YHvUGiR9TFP65wJ8vC7t22UrOM0i3FboLIFaP7vl97DIynA33m/X7t8RBVuE6MNXZnL1CcZqYy578zSu/84Q8rT4csJV309eF6l5RXkM9U3GtF97nL/H6sXGVw0fmsxfmxmpb0O1y/LgvNhkDs3WnWqkOKoiCLBp78a+0BoZ9N9cIx7DCL63LJv1xVq5jPAADAxndjBRzOXJY5UxTc2aTSqxWfRQ0BKOS6KIcF8NJzGeSwtzwMxwMvwczTF0whOpzbYEj26Nj70yW2L5OWrvLlnueyf1+NJW13K2fOyoV5UykpvMPCglyPKlF2eIF/bthtq3DMesIPJUiNSd8j3Z11mV5s8KodQbAhv6dIh2wK0sF2Xy9ZoSqTZnGLu9kOnR+irPQ57YIXpT9tK5k7pC/qkq9zLgQTpFrBPtpz0z+PZdYRK5XPEq6ynKVzTGgFdzE9nmbk8lVT770j+/3l8lnxb2Xz82P1LPF32B+vZL4VP/REe0hogC1ap31o4EkDDOa5Du+wn+2Q7vuiOR+Cz9rXy63ZsW6Un88AAAAWbwPdpUIn12os8DfMuK3dfeOuy1ooDLuGawE+qFTEs6u3WLeuU7uTxwVY/ftglvLUd3o61rhMgTf72dwZ31uw6yh3l4owvWx6N1TutFXWryfcNrNdOjv8PjnuP9+YZg3HoiW3jjJ3qUit2y7Lu6tGWZl8YITrT838bo7j7NVu2XEt+/1BxTY+1m69m04n+1Ocpxulj0k2/6qCNCuSl0cNraDpevJnuw++P/v5svk70jTNsvtcl9lzXdIdp1nmXNN3zLb2x8cjPJa6vXoHgeiuL43H2QrOsfC7NQ9Mbx6Rnc9GaZvO4wvnZmWuZ0dqW1R2+5vepcKI81nD8cg71sm6o+PUnuz2J3m4dT7LbHuQZoXnR24+S9af/t5IlGbp7Y2k0my5foet5umVlvleK51ezT/bjPt83l0qitMs0mTbS+YzAACAxVpXAYf1yRUUw0pmUeERAEqzFUa9ywCVxGL8DgMAAKwG5nBYdttlU7YF1d5ibQ1MAAhgndIW6wmCDaXxOwwAALAa6OGwEnK68i6uCzQAYFH4HQYAAFhxBBwAAAAAAEDlGFIBAAAAAAAqR8ABAAAAAABUjoADAAAAAACoHAEHYFH0lnpH5dAu/xLr2tDohIzu9S8AAAAAVGKDBhy0MjghExMVVwh3HZKjeiu60SH/xkbj0o2KF1AdDWZU/lsEAAAArAPr5y4VObc0c+oyOTwmJ/0rV2keke6rkzI8lrxbCQ047O+WjvoyrLuZhv1eWMb77ru023S6mlvFaUVrMHPI1sxt6DRdd1+X8UOHZXF34de02ifyRLvHYkhGJwYlTJaNcWs+f951+peLOkeidWTzeDrNFs6Ny4EjwVGLzkv/UuZn2z6umld3PtvOccjsbyC7fe48WM7zdpFS6RZuX2MejdM0m9aRIM0bz/uy+94sTYPPp34PG9fbe/CojPREW5e9NjRuW/rcy+535vOZfc+et8XrVun1p5a3WLdK7Vsmj6e+exH5HwAAYLmsw9tiukLpjouZSsdGlakYu0LnXENBuhoubasMOPRfW6PHaVUCDhs379oKj0RBBlex6soGBlqweXvznNRrXXI9rkhm08ytW+IKmb7uL/j7cnT72ws4BGwlWJbpnFwmdpu7mgQCNE13yvmS+5M+9ktMy6xU2qa3q+G3MHMc7PLbL6R/OzdPJ4Gw1N83/vbl5ek439kAwQ654NOveN2GDyjM5QQSWq3b/oVuy5b8QEJ2P7PHAwAAYDVtsCEVWnDT7svucfRgr3/f0ELcxKj5i+BvDh8yxUxDC4ejh0yB03d93qt/Gyw3tBCXu15lPz9kC37N/ib8/FK6V89cmfPPEuH3ptethWh9HaaLpkEoXNbYuth0u0ukWSvp7c4M5dD167rscfN/kxrKUnCslX4+b3m0Pm0l7eyWkfhvsumyDHb1yY7OBbnwdHFFuChdljXNDLf+NvOn+b5+bcGfiio4J+XUuQXpuL2vdF7QdezrEbOO8/4Nb+8ekyfrMh0HD9y6a3f4/dq1TbpkTi7HleYZuXzVP11t4XHI5q8y508qD+cfE3d+tpt3ze/C7mbBhnYNyc7Usa/W0B01WTh3ylXazf/Hogq8MfP0BVkwR3+bTRfdp/BvzfIj01Lv3CF9Pt22b+6QhWuX3AtVv24+H9kum8y5eb3uXxqXriVLew/2S21+Vk5FwYIzh2W63iE77nJHq3jdZj8GmgUbWq/bnl9Ngg2a/nt6OqR+Oll2cmpWFmo728wTAAAAy2MDBRy0cu1aVYeHh81jUuZ6RjLzEdRk0LaGuuV1U+HcEy2vddvWrUlT0Ose2CTTdnlSWD05pp/R5e51g9qga+HS756qS0fPnrjAp5U42zplt2tYxs+JdO9fXAVXC+Ayf13ioq0pjO6R4+57o3XfF1b6zf7sj/Z5XGbna9IfVzSzaabL/SKj5Xa3SLNCpjLlWifdujXNagOZSpUGBPbres3yY1qI7vfLWx1rU7G2rbd+3eYRt3abwvwB/32267FfPhxUZJbNmbNyYV6PR/MKvaZ5Kl3MI66kLGuaLUFtk3TMX5CzUeXVbmeH2ZZNphpXhtm2+7pFzh3PrwCH+d2wQbct21wet2lqzuuoom6+W4cvtArqrIgor+lx8G+lFJ0/GqwI8/DU3KJ/MxrYwJdJw7uC4FUbgcKQrSzXpysIXOTQinYtDDa1Nncl/NtLct2cb5v8UIOTz+rvcpTnXZ7rqJ+Pgxnn9ThEaWy+e59W5J8NfhWuXk5V+DUg0bHZ5fDidbugzPWtYQApcywL1t171w7puCrSZ4NT7pEOFqYDJXLmsszFgRgAAIDVtXECDlqIllk53qwl1KtPRa16WsAU6drqC25BC1PYSlaaVl6jLqwnzks9LvA1tkDNHDluK/47y1b2gpZ421U2bOkylZqxoEBuW/0yFb1kn2fk7MWkIGtbj1NpFiqx3SXSTAvhSSE7qhybAnmmNVJOjNmKV9yqZ+kYbR8I8JV1W3kodayz61oLZuTwoShwk1dx8Gk+lRf8WIk002N8wFRwF9nyrZVkPc62K7mpPJet9BTlQz2XwsCgSaPR1JwmPk0v7nDniP3uKlruV0DB+aOVzFQA5sSp3N8MFwhtM1imASKpmfwQBSrHTeqb35hUbxgNzmbP2yzNr9orpfHbawPRZ/N70pShvQKk6W9xVKmPgh3ut622Owmc9B7cl+6xZc4XDbSJ3TY37CYcdmDTckrcftshDUmwz/6uxsE7wwckYkXrtr1wOqR783mf3hpkSoJkrdatvSekZvLDE+6zGsCSOLjhAyUDybEbGs3MvwEAALCKNk7AQQvRQcVcH8nkYZG6nI9aiw0tYK7MWPpMC1S7opZ4bZVv6CprCt5By9dE3oRui7bE7TZ0Ar2okJ2tyKZbI3OErea+YmkrAC2P9UkZ84Vyt7yiluGKuEp9UnGIhz3Yiklxmi9fmi2RrjvqWaEV4IahDs343ihP5HUXV+ZY2p4c0XbvlPN6HsQtwi7/R72Lxs912QpjJT03VpFWMtPBuvwJKhfN/KYkAR6TT06bNI16jWiax+esedjeFY1BBzcUIMxvTtQbzD1cT5q2gw62d0PznipDoyY9JAjyGjYgqoETn2b7ZFpm54PzyQ5RSXq46XaFPTvs8BSd1yXe5yBYcuawHA8ChRP3iUyfW0iGUbRYt157JsPghg57iALDrdZtLITBJ/P302afomD5ybFJqdcG3WfNY+ezGuwrc+4BAAAsv401h0NUMQ8fQSFv9STdeh0dL+yftsO3ciZDIoKCd7S/zbpvL0pF291E3LvE6pVtW/zTMlod66g7u3m4SujaCjpYtqJhjlY8PEC7Qhdb1jRbLDtePehZoewwi/RQiFx7d0pNW3+jypadxd+/jgIxtvU42uYxubS1K6jouTkeosqcBnPGtedG0NK9XqWDde6RNwdA2/R4lR7uYtgeW1mNPaDyuZ5k7dLeDUnvhTQNDAzWzDFvmNPABdiitDpwRMzvVVTxjnoIRRV3DaroEBbfe8YHOOLAl+a5qfTQuDhQqA/z3bK5wwcAW6y7xBCH5utOD6/Ilw4QjdW3SVeZcw8AAGAFbJyAg+96vW+R3XeXjytwp7v6ZiYJK821RIaFYCts7dVuxvZ5Cbbikcy5YIMXcUChyu3O8kM7wv1omBywQJvHOm+izey+r45e6bvdHK34+Pnu0ak5OCIrk2aLmjQympsi3m5fAbt41u+XE01Amup9kAom6ENbZzV4YZ7nBEPsHBe3X8gMvwgrc9k0XZ/cnAD7Wh6HRU0a6ee9SM3lknO8IraLfqYnQ+nfgiZzauTmhUhU+c8ZqhEHG1oOI9EJUvXOD+m/S1XcbbAr7FGUDrA2zJcTsNshk6kAUPN15wx7sAGVaI6HtOy684ZcNO39YZbZO1w07TEEAACwsjbYbTFdITNslI/vZ24LYtrlO6egqt1h/S0St5vCnruV43azruh2e43rVfH99oPPuy3Sv48+a9/wBWX33GxViQKz17But//dV/1tz+x+JUGG+rlZ6eqJ9tP9bXirN1thC27f5iYpdJ/W/ZnePJK6pV3T7W6ZZu6zRbfFDL/bfLupZAZDLhr2O6vgWOtnU+P8M+v20t/fxjGxNG3bvC1mw3YZ9cbb16XTPNgvY9nSzHPrl9z0KubzpQ9YxedGINqv7HemZc+d9Hrz0iudJkbO37Si21b1bTEbtsvy+Sw4Vs3On8b80phHXZq2m3dVOi+kjlf2e7Pp6X9zim7xmHw6f9ua54XM71so81sXi7Yvtd1553x223LOn3C/tUdQfC4VpJfVYt2F+bjVuo2CfVva7xgAAMDyWocBB2AtWETAAWvWkgIOAAAAAHJtrDkcAAAAAADAmkDAAQAAAAAAVI4hFQAAAAAAoHL0cAAAAAAAAJUj4AAAAAAAACpHwAEAAAAAAFSOgMMapLfoO3qw178CAAAAAGD9WX+TRu4dlYmBmn+xILPHDsjhM/7lBqEBh/5r43LgyIx/Z3F6Dx6VkR5Jp5FNv67Ue/p9g1GSSl0mh8fkpHmWfl8ly1aEbuvu6zJ+6LAsLSUAAAAAACttXfVw0Aq0qywPy/CwPo6LDBwS+gLkmzlyQCbrHdJ9X5RGQzI6UJP6VBRs6JVDhydkcMusjNv01Md52Tk6ZP/aqk/694fNumoyGC4DAAAAAKCJddTDwVSWJwZFpoZl7IR/K2vXITm6v1s6/EtbWR7T9nitWO8TuTgn3T01+/6kDNrW+3q8Pv2bEenu1OdG/NmE6zEQrz34rJHqeZFepp/bJ8dlevNI3GMg9dnsdxsL55IeDoXf21KSbufvmDB7HeyX3WZp2mvB9nDI/n2qx4Fbd7zX87Pp3ghNj4eXSbN4n7Ofi61wDwsAAAAAwKKtnx4Oe3eaim1dzjetaJvKr6mkzpmKtWuRn5R6bTCYC6FDum83leVjs7Jg3tchC+PnFqR2h2uxHxo1Ff6rpkJsPzsus1vCz0aV/jlT4Y3WH1b6zXffcT5+f3iqLrWBUfNuoqNnxH6nLrffuzvpmZH+bu1J4BcoUylPfa9d91E5tMsvb+mknNLvG9DhEQsyO5VU14fu0IjL+dIVeP37hYtnfUBBgySD0nXO7ZNNM+mWkbgHRKvjYZaneqsMJ0NIzhyWA35fbRDDLx8m2AAAAAAA68aGmTSy92C/1Ezl9FQcBDgpY6bC2nF7X1yxr5+OWt/rMp2aH2FIdtbqMhm3vs/I4dPhZ4dkT0+H1KeaVXjNd4Ut9yfOm2/okm1hUKA+GVeoZ56+IAudm2S7vth1SPpT3x0ylfrdppJ/7lTyvSfG7DCJHXclwZBWZo5Mm+0x6tPN57vQ3gYTE+4RDpuoDcbv69CL41G67d0j3Z1hOpo0e0KDOTttoKXM8dAgUDv7AQAAAABYPzbWXSquXk6687dj1zbpkpoMRhVufQRd/d3yBbke9jzI0OEH8WfDYQYVmLuyqL2KDY367akNyuhe+1ajE2O2F4H2vkjRYRC+h8H4xR0yMhH03Ji/Lpf801yFx+OkjB2bFekZ8WmW7hECAAAAAFjf1k/AoX7dVPlrsrNZhVlt2Ra0nov0bu3yz8rQ+QGirvv+Ec1HcOayzNm/yafDLQa1l0L82UnXo6AiXVtTeyXbtvinZewddUMpjrmhGuFQj0vXFswbrkdCGa6nRNBzI+qlEaltSs+70Op4REMnzGP8XJcMEnQAAAAAgA1j/QQcTOV0OlNh1sr3oVE3F4IbptAte+KAhB8GEQ+jKHDmrFyYL7oDw0k5n7rbQ46gtT/uUVCGDWYkgRQXvHDPdZjC2YsL0tGzJ9nnhqEMRdyQjGgoxckxDYTUpN/Po+ACCOXvPOGGSVyQszosww4bSdYVfVc0/KPd4zFzJSeko0Gmzh3S12y+imgYCHfOAAAAAIA1Zx3dpcKxd06IK+Tach/d4tHI3N0gudODTnA4IptOD8tYXf9mk0wPj8klnQhy83RwJ4vmd4rIW57cLSJ9t4aFc7My17NDrvttsxNOxt9j2O1022DfCe/WUJ+U8Wv99q4W0Xen71KR2ecCLq0yd3bw35Vse+N+RXeTSKe1yqwrs98Nd6FoejyMcJ+t/P1K73v+vjR8LwAAAABg1a27gMPqCgIX8WSIAAAAAAAga2NNGrnstsumzqJbcwIAAAAAAEUPBwAAAAAAUDl6OAAAAAAAgMoRcAAAAAAAAJUj4AAAAAAAACpHwAEAAAAAAFRu400aueuQHN3fLR31SRkeO+nfrMhyrnu57R2ViYGaf7Egs8cOyOEz/mUz0f7aF3WZHB6Tor0eGp2Q/mvjcuDIjH+nCkMyOjEo8Zafq3r9K2mlbqu6kdKsYjZPb5LpVF726TU/K+OHDkvzlOK2uEsX5s2c36Eyvznr+Xd4SVz+6+70LzP7r7+/g7WSv+0AAAArZF31cOg9eFQmJiZSj6MHe/3SErSgOjFqirz5tMDW1vpWhBbQ0/s8cfiQKXq2w6xjoCb1qWEZHtZHyQLpmcNyQP/+2KypGqyOoVFTOdGCtd3uYSrOJSwlzaJzbHSvfyNDz5E4H46GZ5JWhpotu4FpoK/t83UluOPV7Di3svjfypMyZvPlpNT9Oylr4DenKXv9CPJ45rimr0/Z68zSz4/eg/ukW2Zl3J/X5YMtSzvWAAAAS7H+hlQEFancylRUYF2Olq/lXHchbelL9nm4sBU2x65t0mXWcX7dtcr2yrYtZu+fvZFaMZdqsWnmKiX75EJ+RdAvH5Tg/Eu1ro5I99VomalM1gbXYPCuGV8Jbve8wupYld/hIRndv0MuHPN5f3jcVP27ZV+Ux/eOykjPXPw7PVmvyWAQkKji/Ni+uUMWLp5tmkdPjum66d0AAADWlnU1pEJbkEY2TzctaLoupe55uht52I035Lqfnr3LrLfHdeJNCbqsNl+3oa2Yd5yX8Wv98XqyfxN+PlKuq7tu+04532I4QyE7nEKKuyf7l9luupb9m2w3dKWV0KCLr1GY7i27rGe5z8tUThf2ou2Ot/e87Iy+v63vzuxXQ5pk9qvV8vi73Xo3nZ4UGYiWtx6qErLnQJBXtddKOm0K0qyArnfPlQPmM00+7/N4Q95QNr21MpZUdux23n6hjTRvlmYqczxSy/Rz5vw4dl36o/yQPdY2/8drNpI0T6VnXt7PbpeRSvPMuuNl2fwZC493i3yWWXe534vW8n6LVLj+Zvks+34ste2ZNGuarv1yvVn3/ya/Oav2O5yzPbouN4RM7HHccTFYT3hOSBXnh8srqe+IpPJa+vekzLFernwGAACgNtSkka6FR1uX/Bsx34Jpu+mGvQVcAXDmyIH4c1rYcsvMIygkN1+3Vxt0wRD93FRdOnr2mCK1Zwp0g7Xoe8dldt68Zwrhy12o00Kt7b5rC5M1GWzozmsK/aagOmcqE26f22t5S7faNaaNdu3vCtOzbOFaC9B2W12lpTbgtzvuplxmu3V/tULjl3d2y56SXYrT+2WO15b0uodGNQCU/u6ku7KrbBXtd20g2i7NCzXpL9vSafJR2Iqq+aw2cFQO7TLLWqZZMT0HigIUQ3fUZOHaNrNv0XqDLtq1TdIxf0HORhVHu52m+tO5Sbb7t4oVp1nvwT0iT/j3sy3LljnWtjKoyzPHWtNloEtmo5bpTFf96NwfP5fXgV8reeF2+XM3ZrZbgzB2mXnY4+HTO2qFN+/ZAEj0N6nKYFE+M+sOt9s8qvq9cL9lbl+SYVbB+gvyWZnfyuLzY2lW7Xf4zFm5YM7VuNeCXdeCXHhaP7tdNnVGz5X7feow/22yJ+NSzg89N/R8c4Gpjp4Rf/75814VDENpeayXMZ8BAACo9RdwMAXKqMKTqvSsNq1URIXuE+elLl2yzRcItbIm9fO+ojEjZy+aYuGWba7gWkoQLAgLmi1ElQNb6QkDLX47ew/224nyTsUVzZMypoX02/tab5upyPVr4b2h5TKt1LqyogK0VlbMy6Sg7CprZbe7PhW1KJ6U82ZFXVvLbMmQ7Ezt14wcPp1e98mxsNU1ve5o244XFNqT7XJ5oWNzmWq5qfzuNpX+c6eS7z4xZipeHbLjLvPdLdJsadwwjY6eTUlFMqiExqKgh+1No9uRnANFWqXZzJGxoBU8L820p1K0n+njMTTQLXLuePD5NuzdY8fMNz+WJt+F+T9z3hdrnc9Mirtju6Ja5LMSis6PZbdsv8Pm+BwalvGLO2QkzuNJjwVHA1T6G+16CGlQJLXfizo/fLDcBw2SIE/2u5diNfIZAAC4Uaz7ORyKWmXXikvXTMG2ttNUMVSv9N1ePBY3LSpw+sfUnHTvLx90aOnq5ZLb0b6TY6aQbKpstoBuHpUGh1pud3rOCm3pK9VyZ+e7CAM8WkHQZsrA3tFkmXmEXZZ1nPVypuncleVac2v1qaAieeKUqQD5FlzVaY5z3MvA/J1Nxzm5XKJS1DLN4t4b7pHbpX+VaJf1JC+kh14UapnPzHl/bFYkbtEu11OlKkvKZwXnx2pa2u+wCyZEvSfGz3XZY5f8pnWY3+URewcTd11yQbo4HZdwfiyv1c1nAABg49tQQyrWqpkrc+b/UeVipEWraQu21a5CmRa+3q1d/lkVXKugDZSYQm3XQIVBh2Xd7qA3SPSIuvjbLvrhHT/S3bttpWYZpVuKXaVm+c3I5asFrdT167KQ6mVg2G7k1+WSf1mkOM1c93QJuu/nD39YeTpkKemirw/Xu6S8gnym4l4rUQV35SqDi85nLc6P1bSk32Ht7dKZ9EjR3mOaD2u7dYjFJbnuex8kAXA3zOK67vsSz49lt4r5DAAAbHw3VsDhzGWZMwXOnU0qvVrxWdQQgEKui3JYAC89l0EOe8vDcDzwEsw8fUEWUnMbDMmeng6pny6xfZm0dJUv9zyX/ftqLGm7W4nGahfets5XJJQdy+2fG3bbKhyznvBDCVJj0l0laHqxwas2nHw2Ox7efbftRWLTrEO674tm5ffd8ku2HpdJs7il2FRo97XRwyF9Tkdj60vSimLnDumLuuTrnAvBBKlWUGm056Z/HsusI1YqnyVcZTkr6sK/mB5PLohUuyP7/eXyWfFvZfPzY/VU8TscDoFwPSRcz5wozfbFx8ENE/K/00s8P5au2bFulJ/PAAAAFm8D3aVCJ9dqLPA3zLit3X3jrsvuLhXJWFgtwAeVinh29Rbr1nXuvp6ZOT+YgT31nZ6ONS5T4M1+NnfG9xbsOsrdpSJML5veDZU7bZX16wm3zWyXzg6/T477zzemWcOxaMmto8xdKlLrtssaZ7gvL5MPjHD9qZnfzXGcvdotO+xs9eH3BxXb+Fi79Wq362h/ivN0o/QxyeZfVZBmRfLyqKEVtNS2xt8d5AMrnWZtH+umadb4vbPnuqQ7TrPMuabvxHcPsJ8OtkvTa1o27Y/u+tJ4nK3gHAu/W/dpevOI7Hw2SpN0Hl84NytzPTsa7rzQPN0K8lnD8cg71sm6w+NUXnb7k2OW3ua8785se5BmhedHbj5L1p/+3kiUZuntjaTSbLl+h42Gbcv8FqeWN6x3ieeH/3zeXSqK0yzS5FiXzGcAAACLta4CDuuTKyiGlcyiwiMAlGYrjHqXASqJxfgdBgAAWA3M4bDsdCyvfxrZ1Sc7zHurOQEggPVMW6wnCDaUxu8wAADAaqCHw0rI6cq7uC7QAIBF4XcYAABgxRFwAAAAAAAAlWNIBQAAAAAAqBwBBwAAAAAAUDkCDgAAAAAAoHIEHLC26URvo0P+Bda1XYfk6OFD0utfAgAAANjYNmjAQe+vPiETE0fl0C7/VhW0wqS3oqMCDKwtnJsAAADAmrN+7lKRc0szpy6Tw2Ny0r9ywYYR6b46KcNjybuV0ErN/m7pqC/DunPpvfYHpZb6vpz9i7bLvZKFc+Ny4IjeW95/3r3trNi2K7etm04v4dZzetzvON/2NvcePCojPVGKGPOzMn7osKz7O+6nzoMFmT12QA6f8S/LitaRyQvpNGtyXnX6l4vJR5pP7xM53s5xKHver/i5Wd7Q6IQM1nKOVea8bbhFY9GxzqZLZr/dd/oXRru3f0x9vtm5E21/s+U5+Sy7XZFk+0rmsyZ5eClp1vCbYaTSrWjdXmr/Cvab23ECAIAbxTq8LaYrkO64GFWqNzhfqJ/zBVRbKL79QlLA94XgsADbe3BU+p4eM4VhF3CQeFn29XJbpYCDTRPJVJg3AJsXdsgFX9FxFaS5NvdT80C/qfGI1GQ6SddMmmXzmb7eJ8dTgayuOLBVkm5/uwGH2Ho87/35dm5WunqS4+bo/uwTecK/Z9O/K6nEtnWsW6RNZl0tpc45t+7GAK4/t6/Wpbblek7AoUk+y8rZz9b5rMm6l5hm6e/O0u/cKefD8yO17mbplKPd4wEAALCObbAhFVoo1KEU7nH0YDBaXAt5E6PmL4K/icaTawF79JApMOr7R+XQXv3bYLmhLVS561X280O2ENrsb8LPtzXU48xhOX5uQWq7zbaYfdjXIzL7RFS4N4Xc3TXboyGs0M8c0WCDf5FyUs6bQnrX1my6BNuW6ZJevN1ayA6Xa/o67nOupbI2kPxNQ9otg6E7aqYycj6nkhFK55XwWBcvc/s8ujdMm3S6hPkgTJOEX3+b3f+HBrQFfzo+tjNHpk2dqyY7zbaUNTSqPWam5dQ1/4YV5aNTcZrZdXfukD6/XzNHDgQVMZePOjZv969XV/NzU4+VOTYHzfnp0zv6Wz1+TiYP5x0Tf460m3eHRvvl+rFhGXvav5EyI4cPBRXOE+fNseyQTb4VvL1jPSOXr/qnec5cljn/tJQTY0GleUbOXlwQ2bItOAc0j++TbpmVU8/6NzLy81mj3rt2ZPazdT5rtu5K06zBSRkLAhczT1+QBemSbdF5v3dP+V517R4PAACAdWwDBRy04uBaw4aHh81jUuZ6RoKKharJ4ISrBOjyeme37ImW17ptS/xkvUO6BzbJtF2eVLhOjulndLl73aA2KCObp913T5mqQ8+euKKpFdDBLbMybrdrWMbPiXTvz6uI5nOVv24ZsV3GkwK17OqTHZ0LcuHpvBa5PEOysxb+van4+t4TUZrVzX5EFatW220rHVrI9suHgwK5S69xmZ133Yejv8lvPazWyWe16XOwoEKvFf4wr5hH3EKbzUdmH0zVaiSzLg2i9F9zf+PyjF++d9S3fLr1jp/rksFKJkrslW1bTFo+G6Ww206tn6YCSEXMtg3W6jLZpFI0dyU8Npfk+nxSAV7Lis9Nc2xuvy7jx2ZlweQJPWbjGsC7wx2voVHfKh0d6y1J/l+qk2OLbcFu91hnz+uMvTulNn9Bzi5qW3I0BD4zWuSzxJDs0fVMtfq7QNN1V5xmbdIg58K1balAZfraE6j6eAAAAKxhGyfgoJVvUzU8HrSOnQoqFpH6VFQJyLT2z8/KKd9LIGzpLU3HMUeFYNtaGbV+aaG6Q+qnk8L5zJHjpiLeTsu02xc7brhp4VwL2FFhN93invQw0Ir08bgS1Huw3xR8k/3W7xnTYMntfWZtJbe7ttP85RqjLbQ+eOL2Ox3cifY7ySsBbansrMt0vGxGDj+hldXMftYn4+CJDXD4FmCteNSngpbQTE8BR1tLTQW3TGtojqj3iHYH18pzuZ4GJn/sTm9bwrVi2140/h0bTIrG0WfZSl9RXlxbkjwcHlellc6w8mqO9eko/wfOHJYD5ngtZ7DMttqnzkWn6FgnPWlci386uBH8HuiQq+A8bosNLqR/B7QngQS/I2lF+SzNnocN2x1oyGfl1r34NBPp6Bnxy82jacDSbMd9YfDXBTs6ejbJeRu4Mg/zO1obCH+HKzoeAAAA68zGCTjUNkmH9gKICovmkZ0ATCsc54MCvbaMrkSLuwYKrjfrGVGGL/Tb1tr7mrWWaxdtLeyairZ/J5L0MBiXC7ebAnVYkL56uaDgW7zd2v15sq69Rlx6r8RwifJ8pd483DYmhf/tm01aFu33/HW55J82k7SkGhrgsD0kXMUjHEJiKzb+z6oQ9qzQvKv7snCt1dZqRcv1Rmk2l4YNJmlPDr/d+2RaZudzjr8OL7BzhmyA8ee7tkmX7fUUHK94UsCVY3sSaeAjMw9Cq2Ot5587r4dl/Fp/ZuhP9HvgzvvruxdzfroeUBIO2dIgwJYmwTqjVT5L+IBmeB6FcvJZmXUvJc3CZVFvl7ygg+0VY86WOMDspQIhJ06Z8yfsIVTF8QAAAFh/NtYcDtrLIC4w+sciW5Grle2avl02NWs9bhC1pk3KsHYL7+yWfVFB1Y4F7pAdd5UtuLoW3NR47OzY7K1d/plqvd1Rd/ZoCMtaLESfHNMgTLIvl65pb5ECnZvMngY0mOWflhEOIXGPKirnfsx50LNC84YGONJDIfL0St/tZg/iHh8+GGdfR4GYsEKklTUxx3pOLofbrZXAbAV03TMV/dSxMo9FTWq5OBpsGNFhBcfCVvv2j7WdUyCbb2OuB0t7c264YUd6h5xkG8y7Oj9KGNjVAI1/Pbq3TD5zGntXBXLzWat1L0+aZWnvicbgkPvu0kObFnU8AAAA1qeNE3DQYQxhZXzNcEM30t3VCwrbWbaLv+9W7CeQTOaHcEMtOnr2pQrzzbkuyQsXz9rCsitwB/NYRK2Otrtvu9utY/7905griGeHtaw4HTMd9Naw+20qKrljrO1wmJr0x/nIp1mpYTZ+aMJAq/k5FjdpZDQ3RbzdfvhH2GvHbq/tuh1W8NLBBH1oV3N7277cYIirbErYYhtUAsMK6Lp25qxcmK/JYKvjoPtujlfVwbQk2NB4DMod64SbMLHZRKlNehPsTSbTTEuCDdmAbRJg9I8ps50+0Dt2omw+axyuFWuaz1qvu9I0M9thh5IEaRYHG3LueqHfHc7bU/zdLXp3AAAAbCAb7LaYvqDsX6n4dpG2IKuTQeaM/9WC9253a7ftplCpXXIPHNlu1qUTTGphtnG9Su8OYbch+LzbIv376LP2DV9Ydc/NVjW5VVtGbuHb7b/t0ht9n35/qit4dI/4nO3OViL8d3T4l/E+ec23229H2OMhp4KSPSbZ9bek+9bWbTFztitOD/9SZfbbVppSxy9It9R+ufUX3erTVSTjNWfWrfz6c9OrhdSxzstH0f7n7HPAbqNOchp9f2q9jZ9N54NI8Xc00DSv/LaYOXnccPlMkmNVT87/S6l9b8wvDXk09zxsrSEfWAXnpgrzSsGxblh3Th4N9ym8bW4sWn8mH+Zvd8E6Ur99aQ35zLB5SSejzflMO/ksb93VpVnmO7O/F5FgHen1F/9W5qYlAADABrQOAw64oWgFoq2AA9asJQUcAAAAAKw3G2sOBwAAAAAAsCYQcAAAAAAAAJVjSAUAAAAAAKjcugk43PSKH/fPAABYHS97iesY+K1vf8f+CwDAauGahPWAIRUAAAAAAKByBBwAAAAAAEDlCDgAAAAAAIDKEXAAAAAAAACVI+AAAAAAAAAqR8ABAAAAAABUjoADAAAAAACoHAEHAAAAAABQOQIOAAAAAACgcgQcAAAAAABA5Qg4AAAAAACAyhFwAAAAAAAAlSPgsBJ+9T1y+k+Omsd75F3+rWJvlY/Zvz8qH/tV/xYAAAAArDHvetTVW04/+lb/DpAg4GD9pBz9lD9RMkGB+//nb/n3qfwDAFZCeE0KHp86IPf7vwAAYPk1uR7Fj7KNqbiREXBocIv8SBxY+EnZveMV/jkAAMtNe7i9WX6sU+T5Uwdk90/6x4f/Vub9XwAAsDL+RA78dHQtOiPP+3eT69OH5GHz+uEH/esHP+b+AAjc1NfX96J/vqbd9Iof98+Wg0bvXAFvfv4b0nn1GXfCvOWATL3j1WLetvTkeutvuefadehNNfdczT/zCRn4lT/xrxqXOy/Ip/2JGX5nJFm/Fjh3ya2p9wAAq+1lL3Fx+m99+zv238rpELw9t5gn4fUiR/x3kW/IX3z4V+XAx13PvAN3BsHy+pmkEBhf18zfP/OP8mN3mnXEy5Nrj5OsEwCw9iz7NSmlef0krvf460ny+m/lL7a82td33DXl9O7kGpWuPxXVjbCe0cMhY+7C38t87U45+hZz8txtCmX1F+JoXiQ6ifQk0Wjep+sinXe+OR63pIU9e5LN/60c1WjfqRfs+4moBUtPPI0IuojhrXt+y34vAOAG9X//yfdkuEXepN1Vc8bD2qF+GmyIrjH+OhQtswU5LfSZ948+8w2R2q6c4RivcMGGiAYibEFSAx1mnbZHhfmbd9BdFgCwSLXvE/n//bXIXlOOytvlVNxrr/POXf4aQ91oIyPgkPXCX8vfzL9CXrP7gPxITeT5Lz3nF0Teat/XKN3fnHYRuYc/47u61m4zJ00yDOP5LxyVx+2zjF+9zbUgzf+9nLYtRy/I1+0K9Ht/Up8AAG5EHz8qH7UFM0+DBX6s7NT/1OtD/jXm4Qe1J0Kw7EuuR8Pjv/KMC5p3fp/sThXaokKdeTz4Mbl/9/e53nz151yvio9/Xeb039QwQwAA2lB/xvaSe/yFf3Sv5/9WPqo9GuJrzPfI9+q1ibrRhkbAocGfyOkL35DOO19tW3r+KtuN5y03S5d/2khPmlvk5qArUJ77b/ke96Tz1XLAFiTT3YcAADeux3/lV10gIOi5oFxLUNE1pmjZK+Tm7/dPc9y6xQUqkgBHOLQCAIDlQ91oYyPgkOPx03/veixELT2hOCKX5x/lKyXGuoZRvqg7bPQI54EAANzY7ERc8YSRGtSOWn3yFC37hnz9//qnOZ6/6ntV+KEY4YPxswCA5UTdaGMj4JDn40dlQDN5NMlWysfkr2yLU9LFJ+qKOv/MGXk4Xi5y6w82uRftbz3nu7i+Wt4UdFXVsbfcehMAbmA6GWRmvoVkuIN2TXW98NStr0v+7l2P6jjXYFl0/Ym6qfpurc3EgXY/h1HErde/AABgOVA32tAIOCyCtjjFE0X+yVE7QVc4y+rDD35C/kJLblHX1NRM4upj8tafdH9z6x43NjdaDwDgBhd3KU2uDXaSYh8Et0MudDLi4O+iuyLpsniiSF2m15/wLhXN2EC7TtLlJvWKvjtaLwAAy4e60UbGbTEBAChpZW9BBgBAc1yTsB7QwwEAAAAAAFSOgAMAAAAAAKgcAQcAAAAAAFA5Ag4AAAAAAKByBBwAAAAAAEDlCDgAAAAAAIDKEXAAAAAAAACVI+AAAAAAAAAqR8ABAAAAAABUjoADAAAAAACoHAEHAAAAAABQOQIOAAAAAACgcjf19fW96J+vaS//D6/1zwAAAAAAwFq3bgIOU1NT/hkAAAAAAFjr1k3A4dN/dMo/AwBgdbzsJW4k4re+/R37LwAAq4VrEtYD5nAAAAAAAACVI+AAAAAAAAAqR8ABAAAAAABUjoADAAAAAACoHAEHAAAAAABQOQIOAAAAAACgcgQcAAAAAABA5Qg4AAAAAACAyhFwAAAAAAAAlSPgAAAAAAAAKkfAAQAAAAAAVI6Aw4q7Ik/+wiZ5+5NX/GsAAAAAADYeAg6WCwL8x5vDxyPytF+6Xnz1yQcy+7DC+/GVP5S33/yAPPkV/xoAsAjpa1I7AeqnH2n83U9fGxqvCe4zzZcDAG5c6WtE4zUpu/x3/twvaObPHwn+Pn3Nya4rekTrbLUtMVsnaVyeuh7+wh/KV/37If2Ows8Fj9Tf+e90y8L6UGM9M5tGxdtVXCZIb1tePaxFmaLJ8Si1zyURcAjcPf438rWvX7ePP37XB+WNTTLimvYz/0v+2u+De7xT7vKLAABr39OPvEZ+6Qen/G/4lHSPvKZ1Ac7QQtIbH/YvIqYg8UMjPfLH/pqQvbZpgeKNX0quG389fm59XvsAAMvgitS/9N74GvK1v/pfIqlr0p/JF4JriC6fHSxofNRK+eA5+b2/yr/m3PVOv55gfXfLe+V1P65LW22Lp9/xI78on/EvY9nr4Q/+ovzQI3/mFyYV7IbrqPHKex9Lb5e5Nr9b3iR379rq/sB+56fkbr9fX/v6Y3Lv97pFIpekLkEaTb5XHgrTqMV2FZYJMp/92mSP/NKPhEEcDTa8Rj7zU0kd96P3+m1WGmwYlOTzQb2x5T63gYBDE3f95/eKfPKSySJONsoTZm4bbXvkD4PoUfZE+zP5nfizJtN80r/tpdYdFvRspOwB+Z1HguWaATVzhK9LCbehePujyFXT7cqsyy0zGfq9enJ/2mR0937DDwAAoAVTeHv4TfJ7b32tf/1aed27RB760+Lfehs4EFMgMQWZhPld/vAH5e7xB+ICxF1vNYW3T35Kpv016tJznxb5we3ySvdSXrm9J3XtAwDcyLbKvR8JGi+/9yfk7p8Rmb0UtXK/Vn75Iz8XX0Pke7dLt6kL1JsEHL565lPymXcdiCvjr9z106lrUtbTH/tFkfga1mpblKmj2Ir/38jvmWWhp/80cz3Uut7Dn48r51EF+4/NNbeVrz55VB6K98PVgbonwyBDKJNGP/4TpuKepFHxdhWXCb566ZzIz2yX7faVYdL/bjkXr/urT77TBitSQYaYSSsb/CnXOJ3e5/YQcGhCD7686yf8Abgi08/9dNAC9CZ5aDDT7fThT4l8MFou8kvvjSroGlkaMAcoikxlToC8qFaqcv9pmb3tEfdZjfI9PCD/8U9/Inh9tHkUMea2YTbqwWGjj5mAQLD9mim18Jrdrv/hAxFPPxKsyy7Twqn5EfigRiHNSeGje79so5EAgNK+cklm/dPI9tveJPKlS8F1Ic3+Xv+RuUa9MyqQFMgUBm0AQq8rPnidLfgAAJC4JPVPinRvb9LK/eefl4dMXaDWpFJqg9yhogDFV/5QPvzwe+UduZVlld0WbRAdEMmt+GvvCP80kqmcl/dn8gcjEgQB3HY8ZOpW+Q21GfY6H6VRi+1qUSZ45b0H5N2fTOqO2YCOTW+9xkfbFTaK23UnDcX20bQhO7vP7SHgEPjMyGviBP/wbaZCHRfeTGX6nUlkykbjshk0jNZpC1HkK5+Xz3wyjEylpQMbja1PEnZdsSelyLv/s19X3kmqmS7KNOZhgwp+G5L1/Jy8I9tilopYXZHpP/p0Q7TtM3/0eZOZ3YnxmeeS9q+73lkuMgYAKKOnaWGtgQatNdgQtp7Etkr/T73J/3Y34VuI7v7SUXvNeGNh4Q4AcCPTRkdtRG1oVLS9sk3dY/CD8u6mLf3O3bfF7fGF0r0bGqW3xTWuymRxg2fTQEkbGlr6bcU9GOqhjcuSHhaRcL0hZPyRVBoVb1dRmcD1eLhbPmXrfz+UCgq4Otu7TZpEjcS2UTwacmG2+zOpofhT8u6HB3LnaFhK7wZFwCEQzeGgPRgaCmjRiaSPvHFBhYoLj6kTzwcVFi0zh0Ny0qW3wUbHWggDMPoD4mh3Jpcho2WLmTwEANBM+RYX250yDDTb3+oPyhv9xE+vvPcRV/CJlt9sCmhB65OODdWxnR/9iOtKasfTBpNGAQCg7DxBOl9DXm+67/05+aite0yJZHtRZ4SNlk39+SOFAfDGbcn2MnBD2LUuE9ZT0sMvFsHUB/9Hy5Z+U1d6R3q4hqNBETcfQ3aIQ/F2NS8TRMMpo2u4m8Oh+RwatkeEKSN8Iff4vFZ+vkkduPU+FyPgkCMqoEVDCGyw4Ud0bI6vyNsJTNpRXHhMnXg5XWeqkd6Ghi5NOcKImH3ELWivlV+O3rMTtryzxLAOAEBLOUHn7DwLoYZJnewcDtrSEvU80yBxsFyvXz/z09JvAw6u9SNsWcntwQcAuKHFFfzc3nQh1+LerALd0OBp6z3ZIRimYp6ZfyiUvy1B3cQ+3BB2bUx2lfutUvtB95cxbeFvp0ehob0uwiELlr1u51w3w7kVgmBD0oNetdiuFmUCfZ5quE7ND+HW3XgsfHqbdd+dN2dTpryRu89tIuCQy81HkJ75NDgZbEYoyXZX/bR85kwUvNDhDe6pchODJPMw2IMaFwYr4rfhlz7mu/Z8RcdEBUMzGrhuuOl5KsyJ8oifHNL+m8OeFE3GYQEAStDCWvB7bSeMSv9e24l+i8aHNqWTaf2idL8jKqS5wshDH07WZcd/tlkAAwBsXLaCr5MS5wUbtFE2HDrg6xhxIFuX35z0eLBB7aDeY6852XrPnz8mv/TJ/N4NhdvSgh0ePvJYXLfJDmtvye5b3jB5f90O5+/TgMlP/YTfRhdssHeKyOkdUrxdxWUCDeCEn83OoeHWnTQM26ERUXrb+uEH5Y3x8dN5Gj6drh823ef2EHBoRrsG2duWmJPkKzrnQTCpxofPtdHDIQle2M++95J0h5NG/vg7/Xgat+5y0cN2ZYZB+N4aRWOctNXMda31+3yzOVFu0xPHFFDD7rl2XdFYLdcVJ+rOVNSdCgCQ7653/o383peiYWtukt6i3+ti4V2Fjkrtr9K//fa7gt90N1kw8/IAAJSr4KYnHjSPKOitldb4emUereoYtn6l3f7d39trTqreo3dO0Hkg8q5DLbalFVvnSuo22eEh0d359LaYblh5ODThSu7cC5H0tTQzbMI3NqeGqusjqui32K6iMoHW1+ztrqN12rtOBHNoZOqZ6fTO1A8byhvF+9yOm/r6+l70z9e0T//RKf8MAIDV8bKXuDj9t779HfsvAACrhWsS1gN6OAAAAAAAgMoRcAAAAAAAAJUj4AAAAAAAACpHwAEAAAAAAFSOgAMAAAAAAKgcAQcAAAAAAFA5Ag4AAAAAAKByBBwAAAAAAEDlCDgAAAAAAIDKEXAAAAAAAACVI+AAAAAAAAAqd1NfX9+L/vmaNjU15Z8BAAAAAIC1bt0EHM6cOeOfAQAAAACAtW7dBBz+9PP/xz8DAGB1vOwlbiTit779HfsvAACrhWsS1gPmcAAAAAAAAJUj4AAAAAAAACpHwAEAAAAAAFSOgAMAAAAAAKgcAQcAAAAAAFA5Ag4AAAAAAKByBBwAAAAAAEDlCDgAAAAAAIDKEXAAAAAAAACVI+AAAAAAAAAqR8ABAAAAAABUjoADAAAAAACoHAEHNfOQvPylD8mMf+m8IE/c/93y8g+d8a+dmQ+Z914aPt4iT3w5WqjrySzPfL5qV068RV5+/+Nyxb8GAKx3/vrjryP3nXjBv9+au0alr2f2OhFflzLXuux1i+sJACDry4/LffG1Iqj7WGfkN4PryG+mK1QZ6b9trH959vsal2XrYdnrY/p6l9nOFte7xjpek+uvT4tm1+a863BElzV8LpW25pF3HS5K/9R+NUlP5f8uPj7Z740eBd/fTnkkRMBB9b5bLj32l/L6IDhw5cR/lQfluFx6zy7/jjtBXi9fkG/+678nj+fulafeGR6YD8jn4uVfkPePva7FiQcAQGLmQ6+SB384utZ8Qe584FWlriNakHn9mH8RMQWM7Q/8aHxd+tzo++T1QWHiyvN/Ke+fjq5ZX5ZHZZ9sX+ZAOQBgHdHK5m1Pyj3PRdeKj8t9r/LLbID8dfLMY192y547Ls/0ZwMSgZnPJn9rHrb+larg+oDEbfvkKf9O4gV57otBPct8l4TXx8z17pvTPyoP3pZUwEtd70bT9bwn9t7iF3g2LfK2zcm9DhtRICR32ReelDvj7TLX6R/ObFdR+uuy/r+UR/2yxvT0NNjQ/z7/wnvV/fKE/874u0dF7rnnDbLV/4nVYp/LIODgbd37u/LoF6PgwBn56AMijz5yf5zgV078trz/3jAA4enBejz5u7Tb5NZ7RZ55PogG6UHTE8k+2ogQpj5nHpoRzXuHHviEyJMmY9r3C6JaAIB14Ix8duzN8uiD0bVml7zBFADe/7+LgwBamLEB8ekP+HeUKQj+f++Tex77Ben17/Q+eFzuefJJ+ay/9mzd+3H5tWih3CJvuOfNIl98vrGwAgC4AZnryDv3mQpxGGQIfPmz8tSTH5Bfjirmr3qD3HPvJ+SpLzRpCe99d6oSv/XWHzX1mOfkef9ar3m/ppXf58y1yr+TuEXue/zd8fXMfVdSz9KAgtxr6l72lfGfbjPr+Et5rrLrnamn2Yr/l+VR871Z+ddhR787qtBnpbdL5NYd4XYVp78GK54a/e/xsq2vuzd1jbdsUELkc9oQ7t/KZf7ud8aCY2kV73NZBBxiJhM/olG5h+Q3P6SRut9NRe8++9QnGiM+LZkT6Mk3yz2viw6cHjTNND6SZCNvUdAhL0IYBR2izOY/Z6NyJiO+6n45/JjJlBoIse8HJyEAYP358vPyjH8aSRc+GmkhZ/tT9zYGxPO86la5Uz4hz/+Df53x/IVPiPzwrW1e6wAAG5PWZUTeb+okcaNn2IL+D89lWr5vkdt+WOSpC8/518Vm/vf70kGCtrhtu/NWV8/auve/y/u1EdZvX7YynpV7vRt7Xbyf6eED2ij8OpFmFf92rsOFXJ0z2a7i9Lf7EMpe4zXYYAMGreuIM4/uEwkaKFrtczsIOIRsBf4v5f1fPC6Hs11ojChDq9Q4n1TXlffJ66P3zUFKRZJmPmtef0DeEB3J3l+QR6MooI0QBsEJsy2/HLdqucyW9JS4Re57T7NeFQCA9e1H5bayF3ftQqqFnNyedq4F56mnPts0WJFi1vX6sQ/I55ZcYAIAbAg2CB4OF88ZirCIgEEyxMCsu2lP8WIzHzL1rNEvBL0DXI/Ae+RJ2/N7u/ZWj3sLZuRc73rfE+2jeaSGa7hGYZn+91RPhFjhdbg8V7d8VXpIf4n0v2fHbf5ZVtQ7oUTAoKF3Q4t9bhMBh5AdoqAZdZ8cypkUIxwaEWXKS9rDICXMFOaRGT+UPildFDCRLmTaVi1rl/yaz/hRkCM13AIAsIEkXUBbsV1I42F15mHHaGrg21137HBBLZxEy20g/M1y63+yH0/Y8Z06DpSecgCAZm6R+/7bB0TGPpvUbVJDIsqJhhh8c1ri61U77FwJX0wPdY+GNDzxeLTusCd5oMz1zjf8urpftpfBq+RB8/opUy/TXhCtrsNlxXXLe56Me2k0akz/pr1JbLDiEyYNou12DeG6H+l6pOtJn+7dULzP7SLgEIuGLXxcnnhEK/f/NcigbbYShXrfYA5uUHhMnZQ6+Yl/aqULmaluMjpXRBzE+IDJAMzXAAAbju0OmVY0zCEutAXXBxf4jgpSOuY1WK7jYu+9V94QtnbEha+ld5sEAGwg9pqUEwSPGlDtPAkhV7dp3uqeka0nlRAHGzI9CvRamfpeu+7MEMJFXe/8vBLxw81ncM9jX7bzUbS+DrfHzcPg64st0j9pnPZskME3KoR1R/twczjoxJmpXgszH5EHw3k4rOJ9bhcBB8/eleKHfbccO7RC5MHg7hPxuKDsbKat2GEUvueCzfjvk9+JIkP2APthFH6SlQcf9eu3XVtMpvgvGrk7I7/Z5HsbJ1sBAKxf2iU0uBaY3//PxtcCx3a7bNr6UcTPI/TfgkKaLXzpZFIEGwAAWf6aFNeJXnCTEUfz2tn6S1C3yQ4R1zkEXpq0qGsvhLB13U7K38YwQhts0IkZc4YvaOX7qQc+kjTI2jpY0KOv8HqXqWvZelg4D9/ymflQuheGzqXwVNwjvjj9bXBi7Lfjz9t5K7KNCoX8+lK9G6pHwEGZDGhvoxJ0y4m7ocaZz0V6PifJZCL6aByzE87hYB42Y0cRrszQiFSETVuh3G007TI/uaSLQJlM98Xge8NuQHYeiOg76fUAAOtd73u+bO+a5H7z3WTCix9DqZM++WvHS39bbn0u3bJhJ+zKXrca7qAEALhR2WtSPDTP3bY5aeV29Re9fbO9ftj6S/MAtlaQdVL86HrjbmMZ9gTw1yx7G0Z/bYrrYi4AH07saB8+AK89Deytn6P3Mz0Ziq93mbpWi/1oVzJnhRuWEF5ne/+LDv1Itinbe6Mw/bUXgx064j5r07ONuSRsg7vkz11YpZv6+vpe9M/XtD/9/P/xzwAAWB0ve4mL03/r29+x/wIAsFq4JmE9oIcDAAAAAACoHAEHAAAAAABQOQIOAAAAAACgcgQcAAAAAABA5Qg4AAAAAACAyhFwAAAAAAAAlSPgAAAAAAAAKkfAAQAAAAAAVI6AAwAAAAAAqBwBBwAAAAAAUDkCDgAAAAAAoHIEHAAAAAAAQOUIOAAAAAAAgMrd1NfX96J/DgAAAAAAUAl6OAAAAAAAgMoRcAAAAAAAAJUj4AAAAAAAACpHwAEAAAAAAFSOgAMAAAAAAKgcAQcAAAAAAFA5Ag4AAAAAAKBiIv8P0fZttRSWHEMAAAAASUVORK5CYII=)"""

def predict_best_model(model_grid_list, X_train, y_train, X_test, y_test, verbose=True):
  preds      = []
  model_info = []
  time_info  = []


  score_table  = pd.DataFrame(columns=['Model', 'Accuracy', 'B Accuracy','F1-Macro','F1-Micro','F1-Weighted','Precision', 'Recall'])
  #roc_curve_df = pd.DataFrame(columns=['classificadores', 'fpr','tpr','auc'])

  for grid in model_grid_list:
    model = grid['object'].best_estimator_

    if verbose:
      print(f'Começando {grid["name"]}.')

    start_train = time.time()
    model.fit(X_train, y_train) #Treinamento do modelo
    end_train = time.time()

    train_time = end_train - start_train

    start_test = time.time()
    y_pred = model.predict(X_test) #Predição do modelo
    end_test = time.time()

    test_time = end_test - start_test

    time_info.append({'name': grid['name'],'train':train_time, 'test':test_time})

    preds.append({'name': grid['name'], 'pred': y_pred})

    acc = round(accuracy_score(y_test, y_pred),3)
    f1_macro  = round(f1_score(y_test, y_pred, average='macro'),3)
    f1_micro = round(f1_score(y_test, y_pred, average='micro'),3)
    f1_w = round(f1_score(y_test, y_pred, average='weighted'),3)
    pc  = round(precision_score(y_test, y_pred, average='weighted'),3)
    re  = round(recall_score(y_test, y_pred, average='weighted'),3)
    kappa = round(cohen_kappa_score(y_test, y_pred),3)
    b_acc = round(balanced_accuracy_score(y_test, y_pred),3)

    if verbose:
      print(f'Término {grid["name"]} | F1 Score: {f1_macro} | Train Time: {train_time} | Test Time: {test_time}')

    score_table = score_table._append({'Model'      :grid['name'],
                                       'Accuracy'   :acc,
                                       'F1-Macro'   :f1_macro,
                                       'F1-Micro'   :f1_micro,
                                       'F1-Weighted':f1_w,
                                       'Precision'  :pc,
                                       'Recall'     :re,
                                       'Kappa-Cohen':kappa,
                                       'B Accuracy' :b_acc}, ignore_index=True)

    #if verbose:
    #  print(f'Confusion Matrix: \n{confusion_matrix(y_test, y_pred)}')

    model_info.append({'name': grid['name'], 'model': model})

    #fpr, tpr, _  = roc_curve(y_test,  y_pred) #Verdadeiro positivo e falso positivo
    #auc          = roc_auc_score(y_test, y_pred) #Área abaixo da curva
    #roc_curve_df = roc_curve_df._append({'model' :grid[i]['name'],
    #                                     'fpr'   :fpr,
    #                                     'tpr'   :tpr,
    #                                     'auc'   :auc}, ignore_index=True)

  return preds, model_info, time_info, score_table#, roc_curve_df

#Faz a tabela final de métricas-----------------------------------------------------------------------------------------------------------
def plot_metric_table(metric_df):
  fig = ff.create_table(metric_df, height_constant=20)
  fig.show()

  return fig

#Faz o gráfico da curva ROC---------------------------------------------------------------------------------------------------------------
def plot_roc_curve(roc_df):
  fig = plt.figure(figsize=(12,6))

  for k in roc_df.index:
      plt.plot(roc_df.loc[k]['fpr'],
               roc_df.loc[k]['tpr'],
               label="{}, AUC={:.3f}".format(k, roc_df.loc[k]['auc']))

  plt.plot([0,1], [0,1], color='orange', linestyle='--')

  plt.xticks(np.arange(0.0, 1.1, step=0.1))
  plt.xlabel("Taxa de Falso Positivo", fontsize=15)

  plt.yticks(np.arange(0.0, 1.1, step=0.1))
  plt.ylabel("Taxa de Verdadeiro Positivo", fontsize=15)

  plt.title('Curva ROC', fontweight='bold', fontsize=15)
  plt.legend(prop={'size':13}, loc='lower right')

  plt.show()

  return fig

preds, models_info, times, score_df = predict_best_model(models_result,x_train,y_train,x_test,y_test)
fig = plot_metric_table(score_df)
fig.show()

# Assuming 'grid_result' contains the results of your GridSearchCV
for result in grid_result:
  if result['name'] == 'RandomForest':
    best_model = result['object'].best_estimator_['model']
    importances = best_model.feature_importances_
    indices = np.argsort(importances)[::-1]
    plt.figure(figsize=(10, 5))
    plt.title("Feature importances - Random Forest")
    plt.bar(range(10), importances[indices[:10]],
             color="b", align="center")
    plt.xticks(range(10), x_test.columns[indices[:10]], rotation=90)
    plt.xlim([-1, 10])
    plt.tight_layout()
    plt.savefig('C:/Users/Rumble/Documents/TCC/Script_Python/dados/Dados_TCC_2024/results/random_forest_feature_importance_v10.pdf', format='pdf')
    plt.show()
  elif result['name'] == 'XGBoost':
    best_model = result['object'].best_estimator_['model']
    importances = best_model.feature_importances_
    indices = np.argsort(importances)[::-1]
    plt.figure(figsize=(10, 5))
    plt.title("Feature importances - XGBoost")
    plt.bar(range(10), importances[indices[:10]],
             color="b", align="center")
    plt.xticks(range(10), x_test.columns[indices[:10]], rotation=90)
    plt.xlim([-1, 10])
    plt.tight_layout()
    plt.savefig('C:/Users/Rumble/Documents/TCC/Script_Python/dados/Dados_TCC_2024/results/xgboost_feature_importance_v10.pdf', format='pdf')
    plt.show()

for i in models_info:
  print(i['name'])
  print(i['model'])

save_path = "C:/Users/Rumble/Documents/TCC/Script_Python/dados/Dados_TCC_2024/results/"

# Verifica se o diretório existe, se não, cria
if not os.path.exists(save_path):
    os.makedirs(save_path)

# Salva os resultados em um arquivo .pkl
with open(os.path.join(save_path, 'models_result_v10.pkl'), 'wb') as f:
  _pickle.dump(models_result, f)

# Salva os tempos em um arquivo .pkl
with open(os.path.join(save_path, 'times_result_v10.pkl'), 'wb') as f:
  _pickle.dump(times_result, f)

# Salva os scores em um arquivo .pkl
with open(os.path.join(save_path, 'score_df_v10.pkl'), 'wb') as f:
  _pickle.dump(score_df, f)

# Salva os modelos em um arquivo .pkl
with open(os.path.join(save_path, 'preds_v10.pkl'), 'wb') as f:
  _pickle.dump(preds, f)

#RESULTADOS SATELITE
models_result = []
times_result  = []
info_model    = []
info_values   = []
info_time     = []

grid_result = [train_test(mat, X_sat, y_sat) for mat in models]
models_result = grid_result

for index, mod  in enumerate(grid_result):
  info_model.append(grid_result[index]['name'])
  info_values.append(round(grid_result[index]['object'].best_score_,3))
  info_time.append(grid_result[index]['object'].refit_time_)

times_result.append({'Model': info_model, 'Score': info_values, 'Time': info_time})
dados = pd.DataFrame({'Model': info_model, 'Score': info_values, 'Time': info_time})
fig = ff.create_table(dados, height_constant=20)
fig.show()
#-----------------------------------------------------------------
preds, models_info, times, score_df = predict_best_model(models_result,x_train_sat,y_train_sat,x_test_sat,y_test_sat)
fig = plot_metric_table(score_df)
fig.show()
#-----------------------------------------------------------------
for result in grid_result:
  if result['name'] == 'RandomForest':
    best_model = result['object'].best_estimator_['model']
    importances = best_model.feature_importances_
    indices = np.argsort(importances)[::-1]
    plt.figure(figsize=(10, 5))
    plt.title("Feature importances - Random Forest")
    plt.bar(range(10), importances[indices[:10]],
             color="b", align="center")
    plt.xticks(range(10), x_test_sat.columns[indices[:10]], rotation=90)
    plt.xlim([-1, 10])
    plt.tight_layout()
    plt.savefig('C:/Users/Rumble/Documents/TCC/Script_Python/dados/Dados_TCC_2024/results/random_forest_feature_importance_v10sat.pdf', format='pdf')
    plt.show()
  elif result['name'] == 'XGBoost':
    best_model = result['object'].best_estimator_['model']
    importances = best_model.feature_importances_
    indices = np.argsort(importances)[::-1]
    plt.figure(figsize=(10, 5))
    plt.title("Feature importances - XGBoost")
    plt.bar(range(10), importances[indices[:10]],
             color="b", align="center")
    plt.xticks(range(10), x_test_sat.columns[indices[:10]], rotation=90)
    plt.xlim([-1, 10])
    plt.tight_layout()
    plt.savefig('C:/Users/Rumble/Documents/TCC/Script_Python/dados/Dados_TCC_2024/results/xgboost_feature_importance_v10sat.pdf', format='pdf')
    plt.show()
#-------------------------------------------------------------
for i in models_info:
  print(i['name'])
  print(i['model'])
#------------------------------------------------------------
# Verifica se o diretório existe, se não, cria
if not os.path.exists(save_path):
    os.makedirs(save_path)

# Salva os resultados em um arquivo .pkl
with open(os.path.join(save_path, 'models_result_v10sat.pkl'), 'wb') as f:
  _pickle.dump(models_result, f)

# Salva os tempos em um arquivo .pkl
with open(os.path.join(save_path, 'times_result_v10sat.pkl'), 'wb') as f:
  _pickle.dump(times_result, f)

# Salva os scores em um arquivo .pkl
with open(os.path.join(save_path, 'score_df_v10sat.pkl'), 'wb') as f:
  _pickle.dump(score_df, f)

# Salva os modelos em um arquivo .pkl
with open(os.path.join(save_path, 'preds_v10sat.pkl'), 'wb') as f:
  _pickle.dump(preds, f)

from sklearn.decomposition import PCA
# Apply PCA
pca = PCA(n_components=3)  # Keep enough components to explain 99% of variance
x_train_pca = pca.fit_transform(x_train)
x_test_pca = pca.transform(x_test)

print(f"Number of components kept: {pca.n_components_}")
#-------------------------------------------------------------------------------
#RESULTADOS SATELITE
models_result = []
times_result  = []
info_model    = []
info_values   = []
info_time     = []

grid_result = [train_test(mat, x_train_pca, y_train) for mat in models]
models_result = grid_result

for index, mod  in enumerate(grid_result):
  info_model.append(grid_result[index]['name'])
  info_values.append(round(grid_result[index]['object'].best_score_,3))
  info_time.append(grid_result[index]['object'].refit_time_)

times_result.append({'Model': info_model, 'Score': info_values, 'Time': info_time})
dados = pd.DataFrame({'Model': info_model, 'Score': info_values, 'Time': info_time})
fig = ff.create_table(dados, height_constant=20)
fig.show()
#-----------------------------------------------------------------
preds, models_info, times, score_df = predict_best_model(models_result,x_train_pca,y_train,x_test_pca,y_test)
fig = plot_metric_table(score_df)
fig.show()
#-----------------------------------------------------------------
for result in grid_result:
  if result['name'] == 'RandomForest':
    best_model = result['object'].best_estimator_['model']
    importances = best_model.feature_importances_
    indices = np.argsort(importances)[::-1]
    plt.figure(figsize=(10, 5))
    plt.title("Feature importances - Random Forest")
    plt.bar(range(2), importances[indices[:2]],
             color="b", align="center")
    plt.xticks(range(2), x_test.columns[indices[:2]], rotation=90)
    plt.xlim([-1, 10])
    plt.tight_layout()
    plt.savefig('C:/Users/Rumble/Documents/TCC/Script_Python/dados/Dados_TCC_2024/results/random_forest_feature_importance_v10pca.pdf', format='pdf')
    plt.show()
  elif result['name'] == 'XGBoost':
    best_model = result['object'].best_estimator_['model']
    importances = best_model.feature_importances_
    indices = np.argsort(importances)[::-1]
    plt.figure(figsize=(10, 5))
    plt.title("Feature importances - XGBoost")
    plt.bar(range(2), importances[indices[:2]],
             color="b", align="center")
    plt.xticks(range(2), x_test.columns[indices[:2]], rotation=90)
    plt.xlim([-1, 10])
    plt.tight_layout()
    plt.savefig('C:/Users/Rumble/Documents/TCC/Script_Python/dados/Dados_TCC_2024/results/xgboost_feature_importance_v10pca.pdf', format='pdf')
    plt.show()
#-------------------------------------------------------------
for i in models_info:
  print(i['name'])
  print(i['model'])
#------------------------------------------------------------
# Verifica se o diretório existe, se não, cria
if not os.path.exists(save_path):
    os.makedirs(save_path)

# Salva os resultados em um arquivo .pkl
with open(os.path.join(save_path, 'models_result_v10pca.pkl'), 'wb') as f:
  _pickle.dump(models_result, f)

# Salva os tempos em um arquivo .pkl
with open(os.path.join(save_path, 'times_result_v10pca.pkl'), 'wb') as f:
  _pickle.dump(times_result, f)

# Salva os scores em um arquivo .pkl
with open(os.path.join(save_path, 'score_df_v10pca.pkl'), 'wb') as f:
  _pickle.dump(score_df, f)

# Salva os modelos em um arquivo .pkl
with open(os.path.join(save_path, 'preds_v10pca.pkl'), 'wb') as f:
  _pickle.dump(preds, f)

# Apply PCA
pca = PCA(n_components=3)  # Keep enough components to explain 95% of variance
x_train_pca_sat = pca.fit_transform(x_train_sat)
x_test_pca_sat = pca.transform(x_test_sat)

print(f"Number of components kept: {pca.n_components_}")
#-------------------------------------------------------------------------------
#RESULTADOS SATELITE
models_result = []
times_result  = []
info_model    = []
info_values   = []
info_time     = []

grid_result = [train_test(mat, x_train_pca_sat, y_train) for mat in models]
models_result = grid_result

for index, mod  in enumerate(grid_result):
  info_model.append(grid_result[index]['name'])
  info_values.append(round(grid_result[index]['object'].best_score_,3))
  info_time.append(grid_result[index]['object'].refit_time_)

times_result.append({'Model': info_model, 'Score': info_values, 'Time': info_time})
dados = pd.DataFrame({'Model': info_model, 'Score': info_values, 'Time': info_time})
fig = ff.create_table(dados, height_constant=20)
fig.show()
#-----------------------------------------------------------------
preds, models_info, times, score_df = predict_best_model(models_result,x_train_pca_sat,y_train,x_test_pca_sat,y_test)
fig = plot_metric_table(score_df)
fig.show()
#-----------------------------------------------------------------
for result in grid_result:
  if result['name'] == 'RandomForest':
    best_model = result['object'].best_estimator_['model']
    importances = best_model.feature_importances_
    indices = np.argsort(importances)[::-1]
    plt.figure(figsize=(10, 5))
    plt.title("Feature importances - Random Forest")
    plt.bar(range(2), importances[indices[:2]],
             color="b", align="center")
    plt.xticks(range(2), x_test.columns[indices[:2]], rotation=90)
    plt.xlim([-1, 10])
    plt.tight_layout()
    plt.savefig('C:/Users/Rumble/Documents/TCC/Script_Python/dados/Dados_TCC_2024/results/random_forest_feature_importance_v10pcasat.pdf', format='pdf')
    plt.show()
  elif result['name'] == 'XGBoost':
    best_model = result['object'].best_estimator_['model']
    importances = best_model.feature_importances_
    indices = np.argsort(importances)[::-1]
    plt.figure(figsize=(10, 5))
    plt.title("Feature importances - XGBoost")
    plt.bar(range(2), importances[indices[:2]],
             color="b", align="center")
    plt.xticks(range(2), x_test.columns[indices[:2]], rotation=90)
    plt.xlim([-1, 10])
    plt.tight_layout()
    plt.savefig('C:/Users/Rumble/Documents/TCC/Script_Python/dados/Dados_TCC_2024/results/xgboost_feature_importance_v10pcasat.pdf', format='pdf')
    plt.show()
#-------------------------------------------------------------
for i in models_info:
  print(i['name'])
  print(i['model'])
#------------------------------------------------------------
# Verifica se o diretório existe, se não, cria
if not os.path.exists(save_path):
    os.makedirs(save_path)

# Salva os resultados em um arquivo .pkl
with open(os.path.join(save_path, 'models_result_v10pcasat.pkl'), 'wb') as f:
  _pickle.dump(models_result, f)

# Salva os tempos em um arquivo .pkl
with open(os.path.join(save_path, 'times_result_v10pcasat.pkl'), 'wb') as f:
  _pickle.dump(times_result, f)

# Salva os scores em um arquivo .pkl
with open(os.path.join(save_path, 'score_df_v10pcasat.pkl'), 'wb') as f:
  _pickle.dump(score_df, f)

# Salva os modelos em um arquivo .pkl
with open(os.path.join(save_path, 'preds_v10pcasat.pkl'), 'wb') as f:
  _pickle.dump(preds, f)

"""# Reg"""

X, y, x_train, x_test, y_train, y_test = train_test_sat2pop(ground_truth_col='LOG_POP_DENS', feature_list=covariate_list)
X_sat, y_sat, x_train_sat, x_test_sat, y_train_sat, y_test_sat = train_test_sat2pop(ground_truth_col='LOG_POP_DENS', feature_list=satelital_list)

#Definindo modelos e Grid para cada modelo
models=[]

name = 'RandomForest'
model = RandomForestRegressor(random_state=42)
grid = {
    'model__max_depth':[int(x) for x in np.linspace(start=2, stop=5,num=2)],
    'model__n_estimators': [int(x) for x in np.linspace(start=50,stop=70,num=2)],
#    'model__criterion': ('gini', 'entropy'),
#    'model__class_weight': [{0:1, 1:4, 2:4, 3:4, 4:4}, {0:1, 1:1, 2:1, 3:1, 4:1}]
}

models.append({'name': name, 'model': model, 'grid': grid})

name = 'XGBoost'
model = XGBRegressor(objective='reg:squarederror', device = 'cuda')
grid = {
    'model__max_depth': [int(x) for x in np.linspace(start=2, stop=5,num=2)],
    'model__n_estimators': [int(x) for x in np.linspace(start=50,stop=70,num=2)],
#    'model__learning_rate': [float(x) for x in np.linspace(start=0.1, stop=0.3,num=2)],
#    'model__min_child_weight': [int(x) for x in np.linspace(start=1, stop=3,num=2)],
}

models.append({'name': name, 'model': model, 'grid': grid})

[int(x) for x in np.linspace(start=50, stop=1000,num=10)]

#Função para treinar e testar os modelos
def train_test(mat, X, y):
    model = mat['model']
    name = mat['name']
    grid = mat['grid']

    le = LabelEncoder()
    y = le.fit_transform(y)

    print(f'Começando {name}.')
    ini = time.time()
    pipe = Pipeline([('model', model)])

    gscv = GridSearchCV(
        pipe,
        param_grid = grid,
        scoring    = 'neg_root_mean_squared_error',
        refit      = 'neg_root_mean_squared_error',
        cv         = 5,
        verbose    = True,
        n_jobs     = -1,
    )

    rscv = gscv.fit(X,y)
    fim = time.time()

    print(f'Término {name} | Score: {round(rscv.best_score_,3)} | Time: {rscv.refit_time_}')
    return {'name':name, 'object': rscv}

#Realizando o GridSearchCV para cada conjunto de treino do K-fold
#Salvar o modelo, o número da iteração, e os vetores resultantes
models_result = []
times_result  = []
info_model    = []
info_values   = []
info_time     = []

grid_result = [train_test(mat, x_train, y_train) for mat in models]
models_result = grid_result

for index, mod  in enumerate(grid_result):
  info_model.append(grid_result[index]['name'])
  info_values.append(round(grid_result[index]['object'].best_score_,3))
  info_time.append(grid_result[index]['object'].refit_time_)

times_result.append({'Model': info_model, 'Score': info_values, 'Time': info_time})
dados = pd.DataFrame({'Model': info_model, 'Score': info_values, 'Time': info_time})
fig = ff.create_table(dados, height_constant=20)
fig.show()

from sklearn.metrics import r2_score,mean_absolute_error,mean_squared_error,root_mean_squared_error

def predict_best_model(model_grid_list, X_train, y_train, X_test, y_test, verbose=True):
  preds      = []
  model_info = []
  time_info  = []

  score_table  = pd.DataFrame(columns=['Model', 'R2','MAE','MSE', 'RMSE'])
  #roc_curve_df = pd.DataFrame(columns=['classificadores', 'fpr','tpr','auc'])

  for grid in model_grid_list:
    model = grid['object'].best_estimator_

    if verbose:
      print(f'Começando {grid["name"]}.')

    start_train = time.time()
    model.fit(X_train, y_train) #Treinamento do modelo
    end_train = time.time()

    train_time = end_train - start_train

    start_test = time.time()
    y_pred = model.predict(X_test) #Predição do modelo
    end_test = time.time()

    test_time = end_test - start_test

    time_info.append({'name': grid['name'],'train':train_time, 'test':test_time})

    preds.append({'name': grid['name'], 'pred': y_pred})

    r2 = round(r2_score(y_test, y_pred),3)
    mae  = round(mean_absolute_error(y_test, y_pred),3)
    mse  = round(mean_squared_error(y_test, y_pred),3)
    rmse  = round(root_mean_squared_error(y_test, y_pred),3)

    if verbose:
      print(f'Término {grid["name"]} | RMSE Score: {rmse} | Train Time: {train_time} | Test Time: {test_time}')

    score_table = score_table._append({'Model':grid['name'],
                                       'R2'  :r2,
                                       'MAE' :mae,
                                       'MSE' :mse,
                                       'RMSE':rmse}, ignore_index=True)

    #if verbose:
    #  print(f'Confusion Matrix: \n{confusion_matrix(y_test, y_pred)}')

    model_info.append({'name': grid['name'], 'model': model})

    #fpr, tpr, _  = roc_curve(y_test,  y_pred) #Verdadeiro positivo e falso positivo
    #auc          = roc_auc_score(y_test, y_pred) #Área abaixo da curva
    #roc_curve_df = roc_curve_df._append({'model' :grid[i]['name'],
    #                                     'fpr'   :fpr,
    #                                     'tpr'   :tpr,
    #                                     'auc'   :auc}, ignore_index=True)

  return preds, model_info, time_info, score_table#, roc_curve_df

#Faz a tabela final de métricas-----------------------------------------------------------------------------------------------------------
def plot_metric_table(metric_df):
  fig = ff.create_table(metric_df, height_constant=20)
  fig.show()

  return fig

preds, models_info, times, score_df = predict_best_model(models_result,x_train,y_train,x_test,y_test)
fig = plot_metric_table(score_df)
fig.show()

# Assuming 'grid_result' contains the results of your GridSearchCV
for result in grid_result:
  if result['name'] == 'RandomForest':
    best_model = result['object'].best_estimator_['model']
    importances = best_model.feature_importances_
    indices = np.argsort(importances)[::-1]
    plt.figure(figsize=(10, 5))
    plt.title("Feature importances - Random Forest")
    plt.bar(range(10), importances[indices[:10]],
             color="b", align="center")
    plt.xticks(range(10), x_test.columns[indices[:10]], rotation=90)
    plt.xlim([-1, 10])
    plt.tight_layout()
    plt.savefig('C:/Users/Rumble/Documents/TCC/Script_Python/dados/Dados_TCC_2024/results/random_forest_feature_importance_regv10.pdf', format='pdf')
    plt.show()
  elif result['name'] == 'XGBoost':
    best_model = result['object'].best_estimator_['model']
    importances = best_model.feature_importances_
    indices = np.argsort(importances)[::-1]
    plt.figure(figsize=(10, 5))
    plt.title("Feature importances - XGBoost")
    plt.bar(range(10), importances[indices[:10]],
             color="b", align="center")
    plt.xticks(range(10), x_test.columns[indices[:10]], rotation=90)
    plt.xlim([-1, 10])
    plt.tight_layout()
    plt.savefig('C:/Users/Rumble/Documents/TCC/Script_Python/dados/Dados_TCC_2024/results/xgboost_feature_importance_regv10.pdf', format='pdf')
    plt.show()

for i in models_info:
  print(i['name'])
  print(i['model'])

save_path = "C:/Users/Rumble/Documents/TCC/Script_Python/dados/Dados_TCC_2024/results/"

# Verifica se o diretório existe, se não, cria
if not os.path.exists(save_path):
    os.makedirs(save_path)

# Salva os resultados em um arquivo .pkl
with open(os.path.join(save_path, 'models_result_regv10.pkl'), 'wb') as f:
  _pickle.dump(models_result, f)

# Salva os tempos em um arquivo .pkl
with open(os.path.join(save_path, 'times_result_regv10.pkl'), 'wb') as f:
  _pickle.dump(times_result, f)

# Salva os scores em um arquivo .pkl
with open(os.path.join(save_path, 'score_df_regv10.pkl'), 'wb') as f:
  _pickle.dump(score_df, f)

# Salva os modelos em um arquivo .pkl
with open(os.path.join(save_path, 'preds_regv10.pkl'), 'wb') as f:
  _pickle.dump(preds, f)

#SATELITE
models_result = []
times_result  = []
info_model    = []
info_values   = []
info_time     = []

grid_result = [train_test(mat, x_train_sat, y_train_sat) for mat in models]
models_result = grid_result

for index, mod  in enumerate(grid_result):
  info_model.append(grid_result[index]['name'])
  info_values.append(round(grid_result[index]['object'].best_score_,3))
  info_time.append(grid_result[index]['object'].refit_time_)

times_result.append({'Model': info_model, 'Score': info_values, 'Time': info_time})
dados = pd.DataFrame({'Model': info_model, 'Score': info_values, 'Time': info_time})
fig = ff.create_table(dados, height_constant=20)
fig.show()
#-------------------------------------------------------------------------------
preds, models_info, times, score_df = predict_best_model(models_result,x_train_sat,y_train_sat,x_test_sat,y_test_sat)
fig = plot_metric_table(score_df)
fig.show()
#-------------------------------------------------------------------------------
# Assuming 'grid_result' contains the results of your GridSearchCV
for result in grid_result:
  if result['name'] == 'RandomForest':
    best_model = result['object'].best_estimator_['model']
    importances = best_model.feature_importances_
    indices = np.argsort(importances)[::-1]
    plt.figure(figsize=(10, 5))
    plt.title("Feature importances - Random Forest")
    plt.bar(range(10), importances[indices[:10]],
             color="b", align="center")
    plt.xticks(range(10), x_test_sat.columns[indices[:10]], rotation=90)
    plt.xlim([-1, 10])
    plt.tight_layout()
    plt.savefig('C:/Users/Rumble/Documents/TCC/Script_Python/dados/Dados_TCC_2024/results/random_forest_feature_importance_regv10sat.pdf', format='pdf')
    plt.show()
  elif result['name'] == 'XGBoost':
    best_model = result['object'].best_estimator_['model']
    importances = best_model.feature_importances_
    indices = np.argsort(importances)[::-1]
    plt.figure(figsize=(10, 5))
    plt.title("Feature importances - XGBoost")
    plt.bar(range(10), importances[indices[:10]],
             color="b", align="center")
    plt.xticks(range(10), x_test_sat.columns[indices[:10]], rotation=90)
    plt.xlim([-1, 10])
    plt.tight_layout()
    plt.savefig('C:/Users/Rumble/Documents/TCC/Script_Python/dados/Dados_TCC_2024/results/xgboost_feature_importance_regv10sat.pdf', format='pdf')
    plt.show()
#-------------------------------------------------------------------------------
for i in models_info:
  print(i['name'])
  print(i['model'])
#-------------------------------------------------------------------------------

# Verifica se o diretório existe, se não, cria
if not os.path.exists(save_path):
    os.makedirs(save_path)

# Salva os resultados em um arquivo .pkl
with open(os.path.join(save_path, 'models_result_regv10sat.pkl'), 'wb') as f:
  _pickle.dump(models_result, f)

# Salva os tempos em um arquivo .pkl
with open(os.path.join(save_path, 'times_result_regv10sat.pkl'), 'wb') as f:
  _pickle.dump(times_result, f)

# Salva os scores em um arquivo .pkl
with open(os.path.join(save_path, 'score_df_regv10sat.pkl'), 'wb') as f:
  _pickle.dump(score_df, f)

# Salva os modelos em um arquivo .pkl
with open(os.path.join(save_path, 'preds_regv10sat.pkl'), 'wb') as f:
  _pickle.dump(preds, f)

pca = PCA(n_components=3)  # Keep enough components to explain 95% of variance
x_train_pca = pca.fit_transform(x_train)
x_test_pca = pca.transform(x_test)

print(f"Number of components kept: {pca.n_components_}")
#-------------------------------------------------------------------------------
#SATELITE
models_result = []
times_result  = []
info_model    = []
info_values   = []
info_time     = []

grid_result = [train_test(mat, x_train_pca, y_train) for mat in models]
models_result = grid_result

for index, mod  in enumerate(grid_result):
  info_model.append(grid_result[index]['name'])
  info_values.append(round(grid_result[index]['object'].best_score_,3))
  info_time.append(grid_result[index]['object'].refit_time_)

times_result.append({'Model': info_model, 'Score': info_values, 'Time': info_time})
dados = pd.DataFrame({'Model': info_model, 'Score': info_values, 'Time': info_time})
fig = ff.create_table(dados, height_constant=20)
fig.show()
#-------------------------------------------------------------------------------
preds, models_info, times, score_df = predict_best_model(models_result,x_train_pca,y_train,x_test_pca,y_test)
fig = plot_metric_table(score_df)
fig.show()
#-------------------------------------------------------------------------------
# Assuming 'grid_result' contains the results of your GridSearchCV
for result in grid_result:
  if result['name'] == 'RandomForest':
    best_model = result['object'].best_estimator_['model']
    importances = best_model.feature_importances_
    indices = np.argsort(importances)[::-1]
    plt.figure(figsize=(10, 5))
    plt.title("Feature importances - Random Forest")
    plt.bar(range(2), importances[indices[:2]],
             color="b", align="center")
    plt.xticks(range(2), x_test_pca.columns[indices[:2]], rotation=90)
    plt.xlim([-1, 2])
    plt.tight_layout()
    plt.savefig('C:/Users/Rumble/Documents/TCC/Script_Python/dados/Dados_TCC_2024/results/random_forest_feature_importance_regv10pca.pdf', format='pdf')
    plt.show()
  elif result['name'] == 'XGBoost':
    best_model = result['object'].best_estimator_['model']
    importances = best_model.feature_importances_
    indices = np.argsort(importances)[::-1]
    plt.figure(figsize=(10, 5))
    plt.title("Feature importances - XGBoost")
    plt.bar(range(2), importances[indices[:2]],
             color="b", align="center")
    plt.xticks(range(2), x_test_pca.columns[indices[:2]], rotation=90)
    plt.xlim([-1, 2])
    plt.tight_layout()
    plt.savefig('C:/Users/Rumble/Documents/TCC/Script_Python/dados/Dados_TCC_2024/results/xgboost_feature_importance_regv10pca.pdf', format='pdf')
    plt.show()
#-------------------------------------------------------------------------------
for i in models_info:
  print(i['name'])
  print(i['model'])
#-------------------------------------------------------------------------------

# Verifica se o diretório existe, se não, cria
if not os.path.exists(save_path):
    os.makedirs(save_path)

# Salva os resultados em um arquivo .pkl
with open(os.path.join(save_path, 'models_result_regv10pca.pkl'), 'wb') as f:
  _pickle.dump(models_result, f)

# Salva os tempos em um arquivo .pkl
with open(os.path.join(save_path, 'times_result_regv10pca.pkl'), 'wb') as f:
  _pickle.dump(times_result, f)

# Salva os scores em um arquivo .pkl
with open(os.path.join(save_path, 'score_df_regv10pca.pkl'), 'wb') as f:
  _pickle.dump(score_df, f)

# Salva os modelos em um arquivo .pkl
with open(os.path.join(save_path, 'preds_regv10pca.pkl'), 'wb') as f:
  _pickle.dump(preds, f)

pca = PCA(n_components=3)  # Keep enough components to explain 95% of variance
x_train_pca = pca.fit_transform(x_train_sat)
x_test_pca = pca.transform(x_test_sat)

print(f"Number of components kept: {pca.n_components_}")
#-------------------------------------------------------------------------------
#SATELITE
models_result = []
times_result  = []
info_model    = []
info_values   = []
info_time     = []

grid_result = [train_test(mat, x_train_pca, y_train) for mat in models]
models_result = grid_result

for index, mod  in enumerate(grid_result):
  info_model.append(grid_result[index]['name'])
  info_values.append(round(grid_result[index]['object'].best_score_,3))
  info_time.append(grid_result[index]['object'].refit_time_)

times_result.append({'Model': info_model, 'Score': info_values, 'Time': info_time})
dados = pd.DataFrame({'Model': info_model, 'Score': info_values, 'Time': info_time})
fig = ff.create_table(dados, height_constant=20)
fig.show()
#-------------------------------------------------------------------------------
preds, models_info, times, score_df = predict_best_model(models_result,x_train_pca,y_train,x_test_pca,y_test)
fig = plot_metric_table(score_df)
fig.show()
#-------------------------------------------------------------------------------
# Assuming 'grid_result' contains the results of your GridSearchCV
for result in grid_result:
  if result['name'] == 'RandomForest':
    best_model = result['object'].best_estimator_['model']
    importances = best_model.feature_importances_
    indices = np.argsort(importances)[::-1]
    plt.figure(figsize=(10, 5))
    plt.title("Feature importances - Random Forest")
    plt.bar(range(10), importances[indices[:10]],
             color="b", align="center")
    plt.xticks(range(10), x_test.columns[indices[:10]], rotation=90)
    plt.xlim([-1, 10])
    plt.tight_layout()
    plt.savefig('C:/Users/Rumble/Documents/TCC/Script_Python/dados/Dados_TCC_2024/results/random_forest_feature_importance_regv10pcasat.pdf', format='pdf')
    plt.show()
  elif result['name'] == 'XGBoost':
    best_model = result['object'].best_estimator_['model']
    importances = best_model.feature_importances_
    indices = np.argsort(importances)[::-1]
    plt.figure(figsize=(10, 5))
    plt.title("Feature importances - XGBoost")
    plt.bar(range(10), importances[indices[:10]],
             color="b", align="center")
    plt.xticks(range(10), x_test.columns[indices[:10]], rotation=90)
    plt.xlim([-1, 10])
    plt.tight_layout()
    plt.savefig('C:/Users/Rumble/Documents/TCC/Script_Python/dados/Dados_TCC_2024/results/xgboost_feature_importance_regv10pcasat.pdf', format='pdf')
    plt.show()
#-------------------------------------------------------------------------------
for i in models_info:
  print(i['name'])
  print(i['model'])
#-------------------------------------------------------------------------------

# Verifica se o diretório existe, se não, cria
if not os.path.exists(save_path):
    os.makedirs(save_path)

# Salva os resultados em um arquivo .pkl
with open(os.path.join(save_path, 'models_result_regv10pcasat.pkl'), 'wb') as f:
  _pickle.dump(models_result, f)

# Salva os tempos em um arquivo .pkl
with open(os.path.join(save_path, 'times_result_regv10pcasat.pkl'), 'wb') as f:
  _pickle.dump(times_result, f)

# Salva os scores em um arquivo .pkl
with open(os.path.join(save_path, 'score_df_regv10pcasat.pkl'), 'wb') as f:
  _pickle.dump(score_df, f)

# Salva os modelos em um arquivo .pkl
with open(os.path.join(save_path, 'preds_regv10pcasat.pkl'), 'wb') as f:
  _pickle.dump(preds, f)